head	1.9;
access
	prolo
	anoop
	jason2
	fxia
	tbleam
	rjprasad;
symbols;
locks; strict;
comment	@% @;


1.9
date	2001.02.23.17.28.09;	author rjprasad;	state Exp;
branches;
next	1.8;

1.8
date	99.01.15.01.37.31;	author tbleam;	state Exp;
branches;
next	1.7;

1.7
date	99.01.14.04.04.38;	author anoop;	state Exp;
branches;
next	1.6;

1.6
date	99.01.13.21.40.28;	author prolo;	state Exp;
branches;
next	1.5;

1.5
date	98.09.14.16.01.40;	author anoop;	state Exp;
branches;
next	1.4;

1.4
date	98.09.14.15.58.53;	author anoop;	state Exp;
branches;
next	1.3;

1.3
date	98.08.29.19.52.55;	author anoop;	state Exp;
branches;
next	1.2;

1.2
date	98.08.29.00.05.31;	author anoop;	state Exp;
branches;
next	1.1;

1.1
date	98.07.20.19.26.26;	author prolo;	state Exp;
branches;
next	;


desc
@'Documentation about the metarules module
@


1.9
log
@minor formatting
@
text
@\chapter{Metarules}
\label{metarules}

\section{Introduction}
\label{introduction}

The system of metarules is a collection of functions accessible from the XTAG
user interface that help the user in the construction and maintenance of a tag
tree-grammar.  Here our primary purpose is to describe the facilities that
exist for using metarules.  For a discussion of metarules as a method for
compact representation of the Lexicon see \cite{becker93} and \cite{srini94}.

The basic idea of using metarules is to take advantage of the similarities of
the relations involving related pairs of XTAG elementary trees.  For example,
in the English grammar described in this technical report, comparing the XTAG
trees for the basic form and the wh-subject moved form, the relation between
this two trees for transitive verbs ($\alpha nx_0Vnx_1$, $\alpha W_0nx_0Vnx_1$)
is similar to the relation for the intransitive verbs ($\alpha nx_0V$, $\alpha
W_0nx_0V$) and also to the relation for the ditransitives ($\alpha
nx_0Vnx_1nx_2$, $\alpha W_0nx_0Vnx_1nx_2$). Hence, instead of generating by
hand the six trees mentioned above, a more natural and robust way would be
generating by hand only the basic trees for the intransitive, transitive and
ditransitive cases, and letting the wh-subject moved trees to be automatically
generated by the application of a unique transformation rule that would account
exactly for the identical relation involved in each of the three pairs above.

Notice that the degree of generalization can be much higher than it might be
thought in principle from the above paragraph. For example, once a rule for
passivization is applied to the three different basic trees above, the 
wh-subject moved rule could be again applied to generate the wh-moved subject
versions for the passive form. It is important to note that such recursive
applications of metarules still always result in a finite number of trees in
the grammar.


We still make here a point that the reduction of effort in grammar construction
is not the only advantage of the approach. Robustness, 
reliability and maintainability of the grammar achieved by the use of  
metarules are equally or even more important.

In the next section we define a metarule in XTAG. 
Section \ref{examples} gives some
linguistically motivated examples
of metarules for the English grammar described in this
technical report and their application. Section \ref{access} 
describes the access through 
the user interface.
%Section 3 describes the access through the user interface.

\section{The definition of a metarule in XTAG}
\label{definition}

A metarule specifies a rule for transforming grammar rules into grammar rules. 
In XTAG the grammar 
rules are lexicalized trees. Hence an XTAG metarule {\bf mr} 
is a pair {\bf (lhs, rhs)} of XTAG trees, where:

\begin{itemize}
\item {\bf lhs}, the {\it left-hand side} of the metarule, is a pattern tree,
        i.e., it is intended to present a specific pattern of tree to look for
        in the trees submitted to the application of the metarule.

\item When a metarule {\bf mr} is applied to an input tree {\bf inp}, the first
        step is to verify if the input tree matches the pattern specified by
        the {\bf lhs}. If there is no match, the application {\it fails}.

\item {\bf rhs}, the {\it right-hand side} of the metarule, specifies (together
        with {\bf lhs}) the transformation that will be done in {\bf inp},
        in case of successful matching, thus generating the output tree of
        the metarule application\footnote{Actually more than one output tree 
        can be generated from the successful application of a rule to an 
        input tree, as will be seen later in this chapter}.
\end{itemize}
 
\subsection{Node names, variable instantiation, and matches}

We will use the terms {\bf lhs}, {\bf rhs} and {\bf inp} as introduced above
to refer to the parts of a generic metarule being applied to an input tree. 

The nodes at {\bf lhs} can take three 
different forms: a constant node, a typed variable node, and a non-typed 
variable node. The naming conventions for these different classes of nodes is 
given below.

\begin{itemize}

\item {\bf Constant Node:} Its name must not begin with a question mark
        (`?' character). They follow the same conventions used in normal
        XTAG trees; for instance, {\bf inp} is expected to have only constant
        nodes. Some examples of constant nodes are $NP$, $V$, $NP_0$, $NP_1$,
        $S_r$. We will call the two parts that compose such names
        the {\it stem} and the {\it subscript}.
        In the examples above  $NP$, $V$ and $S$ are stems and 
        $0$, $1$, $r$ are subscripts. Notice that the
        subscript part can also be empty.

\item {\bf Non-Typed Variable Node:} Its name begins with a question 
        mark (`?'), followed by a sequence of digits (i.e., a number) which
        uniquely identifies the variable. Examples: ?1, ?3,
        ?3452.\footnote{Notice however that having the sole purpose of
        distinguishing between variables, a number like the one in the last
        example is not very likely to occur, and a metarule with more than
        three thousand variables can give you a place in the Guinness TagBook
        of Records.} There is no stem and no subscript in these
        names, i.e., `?' is just a meta-character to introduce a variable, and
        the number is the variable identifier.

\item {\bf Typed Variable Node:} Its name begins with a question mark (`?')
        followed by a sequence of digits, but is additionally followed by a
        {\it type specifiers definition}. A {\it type specifiers definition} is
        a sequence of one or more {\it type specifier} separated by a slash
        (`/'). A {\it type specifier} has the same form of a regular XTAG node
        name (like the constant nodes), except that the subscript can be also a
        question mark. Examples of typed variables are: $?1VP$ (a single type
        specifier with stem $VP$ and no subscript), $?3NP_1/PP$ (two type
        specifiers, $NP_1$ and $PP$), $?1NP_?$ (one type specifier, $NP_?$ with
        undetermined subscript).  Each type specifier represents an alternative
        for matching, and the presence of `?' in subscript position of a type
        specifier means that matching will only check for the stem
        \footnote{This is different from not having a subscript, which is
       	interpreted as checking that the matching node at the input tree
        has no subscript}.
\end{itemize}

During the process of matching, variables are associated (we use the
term {\it instantiated}) with `tree material'.  According to its class
a variable may be instantiated with different kinds of tree material:

\begin{itemize}
\item   A typed variable will be instantiated with exactly one node of
        the input tree, which is in accordance to one of its type specifiers
        (The full rule is in the following subsection). 

\item   A non-typed variable will be instantiated by a sequence of subtrees.
        These subtrees will be taken from one of the nodes of the input tree
        {\bf inp}. Hence, there will be a node $n$ in {\bf inp}, with subtrees
        $n.t_1$, $n.t_2$, ..., $n.t_k$, in this order, where the variable
        will be instantiated with some subsequence of these subtrees 
        (e.g., $n.t_2$, $n.t_3$, $n.t_4$). Note however, that some of these
        subtrees, may be incomplete, i.e., they may not go all the way to the 
        bottom leaves. Entire subtrees may be removed. Actually for each
        child of the non-typed variable node, one subtree that matches this
        child subtree will be removed from some of the $n.t_i$(maybe an entire
        $n.t_i$), leaving in place a mark for inserting material during the
        substitution of occurrences at {\bf rhs}.\\
        Notice still that the variable may
        be instantiated with a single tree and even with no tree. 

\end{itemize} 

We define a {\it match} to be a complete instantiation of all variables 
appearing in the metarule. In the process of matching, there may be several
possible ways of instantiating the set of variables of the metarule, i.e.,
several possible matches. This is due to the presence of non-typed variables.

Now, we are ready to define what we mean by a successful matching. The process
of matching is {\it successful} 
if the number of possible matches is greater then 0.
When there is no possible match the process is said to {\it fail}.
In addition to returning success or failure, the 
matching process also returns the set of
all possible {\it matches}, which will be used for generating the output.

\subsection{Structural Matching}

The process of matching {\bf lhs} with {\bf inp} can be seen as a recursive 
procedure for matching trees, starting at their roots and proceeding in a 
top-down style along with their subtrees. 
In the explanation of this process that 
follows we use the term {\bf lhs} not only to refer to the whole tree 
that contains the pattern 
but to any of its subtrees that is being considered in a 
given recursive step. The same applies to {\bf inp}. 
By now we ignore feature equations,
which will be accounted for in the next subsection.

The process described below returns at the end the set of matches (where an
empty set means failure). We first give one auxiliary definition, of valid
Mapping, and one recursive function Match, that matches lists of trees instead
of trees, and then define the process of matching two trees as a special case
of call to Match.

Given a list $list_{lhs}=[lhs_1, lhs_2, ..., lhs_l]$ of nodes of {\bf lhs}
and a list $list_{inp}=[inp_1, inp_2, ..., inp_i]$ of nodes of {\bf inp},
we define a {\it mapping} from $list_{lhs}$ to $list_{inp}$ to be a function
$Mapping$,
that for each element of $list_{lhs}$ assigns a list of elements of 
$list_{inp}$, defined by the following condition:
$$concatenation\ (Mapping(lhs_1),\ Mapping(lhs_2),\ ...,\ Mapping(lhs_l))\ =\ 
        list_{inp}$$
That is, the elements of $list_{inp}$ are split into sublists and assigned in 
order of appearance in the list to the elements of $list_{lhs}$.

We say that a mapping is a {\it valid mapping} if for all $j$, $1\leq j \leq l$
(where $l$ is the length of $list_{lhs}$), the following restrictions apply:

\begin{enumerate}

\item if $lhs_j$ is a constant node, then $Mapping(lhs_j)$ must have a 
        single element, say, $inp_{g(j)}$, and the two nodes must have the same
        name and agree on the markers (foot, substitution, head and NA), i.e.,
        if $lhs_j$ is NA, then $inp_{g(j)}$ must be NA, 
        if $lhs_j$ has no markers, then $inp_{g(j)}$ must have no markers, etc.

\item if $lhs_j$ is a typed variable node, then $Mapping(lhs_j)$ must have a 
        single element, say, $inp_{g(j)}$, and $inp_{g(j)}$ must be 
        {\it marker-compatible} and 
        {\it type-compatible} with $lhs_j$. \\
        $inp_{g(j)}$ is 
        {\it marker-compatible} with $lhs_j$ if any marker
         (foot, substitution, head and NA) present in $lhs_j$ is also
        present in $inp_{g(j)}$\footnote{Notice that, unlike the case for the
        constant node, the inverse is not required, 
        i.e., if $lhs_j$ has no marker, $inp_{g(j)}$ is still 
        allowed to have one.}.\\
        $inp_{g(j)}$ is {\it type-compatible} with $lhs_j$ 
        if at least one of the alternative 
        type specifiers for the typed variable $lhs_j$ satisfies 
        the conditions below:

\begin{itemize}
\item   $inp_{g(j)}$ has the stem defined in the type specifier.
\item   if the type specifier doesn't have a subscript, then 
        $inp_{g(j)}$ must have no subscript.
\item   if the type specifier has a subscript different from `?', then 
        $inp_{g(j)}$ must have the same subscript as in the type specifier
        \footnote{If the type specifier has a `?' subscript, there is no
        restriction, and that is exactly its function: to allow for the 
        matching to be independent of the subscript.}.
\end{itemize}

\item if $lhs_j$ is a non-typed variable node, then there is no
        requirement: $Mapping(lhs_j)$ may have any length and even be 
        empty.
\end{enumerate}
        
The following algorithm, Match, takes as input a list of nodes of {\bf lhs}
and a list of nodes of {\bf inp}, and returns the set of possible matches
generated in the attempt of match this two lists. If the result is an empty
set, this means that the matching failed.

\begin{figure}[p]
%\centering
\begin{tabular}{l}
\psfig{figure=ps/metarulealgo.eps,height=7.9in}
\end{tabular}
\caption{Metarule matching algorithm}
\label{metarule-algo}
\end{figure}

Finally we can define the process of structurally matching {\bf lhs} to
{\bf inp} as the evaluation of Match([root({\bf lhs})], [root({\bf inp})].
If the result is an empty set, the matching failed, otherwise the resulting
set is the set of possible matches that will be used for generating the
new trees (after being pruned by the feature equation matching).

\subsection{Output Generation}
\label{output-gen}

Although nothing has yet been said about the feature
equations (see the next subsection), we assume that only
matches that meet the additional constraints imposed by feature equations
are considered for output. If no structural match survives feature equations
checking, that matching has failed.

If the process of matching {\bf lhs} to {\bf inp} fails, there are two 
alternative behaviors according to the value of a parameter\footnote{The
parameter is accessible from the Lisp interface by the name 
{\it XTAG::*metarules-copy-unmatched-trees*}.
At the end of section \ref{access} it is shown how to change the value
of this parameter through the XTAG interface.}. 
If the parameter is set to ``false'', which is the {\it default} value, 
no output is generated. 
On the other hand, if 
it is set to ``true'', then the own {\bf inp} tree is copied to the 
output\footnote{As will be seen in section \ref{access} the cumulative
mode of application is not affected by this parameter.}.

If the process of matching succeeds, as many trees will be generated in the
output as the number of possible matches obtained in the process. For a 
given match, the output tree is generated by substituting the occurrences of variables in the {\bf rhs} tree
of the metarule by the material to which they have
been instantiated in the match. In the case of typed-variables,
the name of the variable is just substituted by the name of the node to which
it has been instantiated from {\bf inp}. An important detail is how the
markers (foot, substitution, head, NA) are set in the output tree 
node. The rule is that, if the occurrence of the variable at the {\bf rhs}
tree has any marker, then the generated node will inherit ALL 
markers from the {\bf rhs} node. If it has no marker, then all the markers 
at the generated node will come from {\bf inp}. The exception to the rule is 
that if the generated node has any children, then it will not be marked
substitution, foot, or anchor, despite what the previous rule say.

The case of non-typed variables, not surpringly, is not so simple.  In the
output tree, this node will be substituted by the subtree list that was
associated to this variable, in the same order, attaching to the parent of this
non-typed variable node.  But remember that some subtrees may have been removed
from some of the trees in this list (maybe entire elements of this list) due to
the effect of the children of the metavariable in {\bf lhs}.  It is a
requirement that any occurence of a non-typed variable node at the {\bf rhs}
tree has exactly the same number of children as the unique occurence of this
non-typed variable node in {\bf lhs}. Hence, when generating the output tree,
the subtrees at {\bf rhs} will be inserted exactly at the points where subtrees
were removed during matching, in a positional, one to one correspondance. If
one wants any of these cutting points to be left empty, as if the subtree has
been removed at the substitution points, the corresponding children at the {\bf
rhs} tree have to be labeled {\bf EMPTY}.

\subsection{Feature Matching}

In the previous subsections we have considered only the aspects of a metarule
involving the structural part of the XTAG trees. In a feature based grammar
such as XTAG, accounting for features is essential. A metarule must account for
the proper change of feature equations\footnote{Notice that what is really
important is not the features themselves, but the feature equations that relate
the feature values of nodes of the same tree.} from the input to the output
tree.  The aspects that have to be considered here are:

\begin{itemize}
\item   Which feature equations should be required to be present in {\bf inp}
        in order for the match to succeed.

\item   Which feature equations should be generated in the output tree as a 
        function of the feature equations in the input tree.
\end{itemize}

Based on the combinations of these aspects the user may specify for a feature
equation to be considered in the following ways:

\begin{itemize}
\item   {\it Require \& Retain:} The feature equation
        is required to be in {\bf inp} in order for matching to succeed.
        Upon matching, the equation will be copied to the output tree.
        To achieve this behaviour, the equation must be placed in 
        the {\bf lhs} tree of the metarule preceded by a plus character
        (e.g. $+V.t:<trans>=+$).\footnote{Commutativity of equations is 
        accounted for in the system. Hence an equation $x=y$ can also be
        specified as $y=x$. Associativity is not accounted for and its need by
        an user is viewed as indicating misspecification at the input trees.}
        
\item   {\it Require \& Don't Copy:} The equation is required to be in 
        {\bf inp}
        for matching, but should not be copied to the output tree.
        To have this behavior, the equation must be in {\bf lhs} preceded 
	by the minus character
        (e.g. $-NP_1:<case>=acc$).

\item	{\it Negative Requirement:} In order for matching to succeed the 
	equation should not be found in {\bf inp}. This is achieved by
	including the equation in {\bf lhs} preceded by a caret
	(e.g., $\verb|^|V.b:<passive>=-$).

\item   {\it Optional \& Don't Copy:} 
        The equation is not required for matching,
        but we have to make sure not to copy it to the output tree set of
        equations, regardless of it being present or not in {\bf inp}.
        Those equations must be in {\bf lhs} in raw form, i.e., neither preceded
        by a plus nor minus character
        (e.g. $S_r.b:<perfect>=VP.t:<perfect>$).

\item   {\it Optional \& Retain:} 
        The equation is not required for matching, but
        in case it is found in {\bf inp} it must be copied to the output tree.
        This is the {\it default} case, and hence these equations should not be
        present in the metarule specification.

\item   {\it Add:} The equation is not required for matching but we want it to
        be put in the output tree anyway.
        These equations are placed in raw form in the {\bf rhs} (notice in this
        case it is the right hand side tree).
\end{itemize}

There are also some directives available to handle feature equations. For 
convenience and conformance with the pre-existing interface functions,
these directives were defined to be included in the {\bf lhs} tree as feature 
equations among the equations for requirement/copy defined above. The
equations/directives will be interpreted and executed 
in the order they appear in the feature equations list definition 
of the {\bf lhs} tree. The general format of a directive is:

\centerline{D{\it{}name1} $:\ <$ {\it{}dummy1} $>\ =$ {\it{}name2}}

where ``D'' is a single character that specifies the directive, 
as listed below;
{\it name1} and {\it name2} are parameters of the directive; 
and {\it dummy1} (which may literally be the word ``dummy'') is required only
to conform to the pre-existing format for feature equations in XTAG.
There must be no blank space between the directive symbol and {\it name1}.
The currently implemented directives are:

\begin{itemize}
\item[$\backslash :$] replace {\it name1} with {\it name2} in all 
	equations from
	the input tree.
\item[{$|:$}] exchange {\it name1} and {\it name2} in all equations from
	the input tree.
\item[{$!:$}] remove all equations where {\it name1} appears 
	(here, {\it name2} is also dummy).
\end{itemize}

Notice that the equations are executed in order. Hence, for instance, if there
is a directive to remove equation E before an equation that requires E to
be present for matching, matching will always fail. Similarly replacing and
exchanging feature names will affect and be affected by the behavior of
surrounding equations. 

In the rest of this subsection we define the role of the meta-variables 
in the feature equations. Importantly, we will overload the notation used up
til now in this chapter and use the terms ``left'' and ``right hand
side'' ({\bf lhs} and {\bf rhs} for short) to refer to the sides of a
feature equation from a tree, and not only to the sides of the metarule.

Non-typed variables don't play any role in the manipulation of feature
equations by the metarules.
Typed variables can be used in feature equations in both {\bf lhs} and 
{\bf rhs} side of the equation. 
They are intended to represent the nodes of the input tree with which
the variables have been instantiated. For each resulting match 
from the structural matching process the following is done:

\begin{itemize}
\item   The (typed) variables in the equations at {\bf lhs} and {\bf rhs} are 
        substituted by the names of the nodes they have been instantiated to.

\item   The requirements concerning feature equations are checked, according
        to the above rules.

\item   If the match survives feature equation checking, the proper output tree
        is generated, according to Section~\ref{output-gen} and to the 
        rules described above for the feature equations.
\end{itemize}

Finally, a new kind of metavariable, which is not used at the nodes, can be
introduced in the feature equations part. It has the same form of the
non-typed variables, i.e., a question mark followed by a number, and is used
in place of feature values and feature names. Hence, if the equation
$NP_r.b:<?2> = ?3$ appears in {\bf lhs}, then all feature
equations of {\bf inp} that equate a certain  bottom attribute(?2) of node 
$NP_r$ to a certain feature value (?3) (but not to a feature path) will not 
be copied to the output. Notice that before the first time the variables ?2 
and ?3 match an equation from {\bf inp}, they are free and can match 
any feature
value/name. But after a match occurs, 
they become bound to the matched values, and
henceforth they will only match these values. 

\setcounter{topnumber}{4}
\setcounter{bottomnumber}{4}
\setcounter{totalnumber}{4}
%\section{Examples of the Application of Metarules}

\section{Examples}
\label{examples}

Figure~\ref{wh-subj} shows a metarule for wh-movement of the subject. Among
the trees to which it have been applied are the basic trees of intransitive, 
transitive and ditransitive families (including prepositional complements),
passive trees of the same families, and ergative.

\begin{figure}[htb]
\begin{center}
\begin{tabular}{c@@{\hspace{2em}}c}
\framebox{\psfig{figure=fig/lhs-wh-subj.ps,height=2.0in}} &
\framebox{\psfig{figure=fig/rhs-wh-subj.ps,height=2.5in}} \\
{lhs} & {rhs} \\
\end{tabular}
\end{center}
\caption{Metarule for wh-movement of subject}
\label{wh-subj}
\end{figure}

Figure~\ref{wh-obj} shows a metarule for wh-movement of an NP in object
position. Among
the trees to which it have been applied are the basic and passive trees of  
transitive and ditransitive families.

\begin{figure}[!htb]
\begin{center}
\begin{tabular}{c@@{\hspace{2em}}c}
\framebox{\psfig{figure=fig/lhs-wh-obj.ps,height=2.9in}} &
\framebox{\psfig{figure=fig/rhs-wh-obj.ps,height=2.9in}} \\
{lhs} & {rhs} \\
\end{tabular}
\end{center}
\caption{Metarule for wh-movement of object}
\label{wh-obj}
\end{figure}

Figure~\ref{wh} shows a metarule for general wh-movement of an NP.  It can be
applied to generate trees with either subject or object NP
moved. Figure~\ref{prep} shows the basic tree for the family Tnx0Vnx1Pnx2 and
the three wh-trees generated by the application of the rule.

\begin{figure}[!htb]
\begin{center}
\begin{tabular}{c@@{\hspace{2em}}c}
\framebox{\psfig{figure=fig/lhs-wh.ps,height=2.5in}} &
\framebox{\psfig{figure=fig/rhs-wh.ps,height=2.5in}} \\
{lhs} & {rhs} \\
\end{tabular}
\end{center}
\caption{Metarule for general wh movement of an NP}
\label{wh}
\end{figure}

\begin{figure}[!htb]
\begin{center}
\begin{tabular}{c@@{\hspace{2em}}c}
\framebox{\psfig{figure=fig/prep.ps,height=3.0in}} &
\framebox{\psfig{figure=fig/prep1.ps,height=3.0in}} \\
{Tnx0Vnx1Pnx2} & {subject moved} \\
\\
\framebox{\psfig{figure=fig/prep2.ps,height=3.0in}} &
\framebox{\psfig{figure=fig/prep3.ps,height=3.0in}} \\
{NP object moved} & {NP object moved from PP} \\
\end{tabular}
\end{center}
\caption{Application of wh-movement rule to Tnx0Vnx1Pnx2}
\label{prep}
\end{figure}

\section{The Access to the Metarules through the XTAG Interface}
\label{access}

We first describe the access to the metarules subsystem using buffers with
single metarule applications. Then we proceed by describing the application of 
multiple metarules in what we call the parallel, sequential, and cumulative
modes to input tree files. 

We have defined a metarule conceptually as an ordered pair of trees.  In the
implementation of the metarule subsystem it works the same: a metarule is a
buffer with two trees. The name of the metarule is the name of the buffer. The
first tree that appears in the main window under the metarule buffer is the
{\it left hand side}, the next appearing below is the {\it right hand
side}\footnote{Although a buffer is intended to implement the concept of a set
(not a sequence) of trees we take advantage of the actual organization of the
system to realize the concept of (ordered) tree pair in the implementation.}.
The positional approach allows us to have naming freedom: the tree names are
irrelevant\footnote{So that even if we want to have mnemonic names resembling
their distinct character - left or right hand side, - we have some flexibility
in naming them, e.g. {\it lhs23} or {\it lhs-passive}.}.  Since we can save
buffers into text files, we can also talk about metarule files. \\

The available options for applying a metarule which is in a buffer are:

\begin{itemize}
\item   For applying a metarule to a single input tree, click on the name of
	the tree in the main window, and choose the option {\it apply metarule
        to tree}.  You will be prompted for the name of the metarule to apply
        to the tree which should be, as we mentioned before, the name of the
        buffer that contains the metarule trees. The output trees will be
        generated at the end of the buffer that contains the input tree. The
        names of the trees depend on a LISP parameter: {\it
        *metarules-change-name* }.  If the value of the parameter is {\bf
        false}, (the {\it default} value), then the new trees will have the
        same name as the input, otherwise, the name of the input tree followed
        by a dash (`-') and the name of the right hand side of the
        tree\footnote{The reason we do not use the name of the metarule, that
        is, the name of the buffer, is because in some forms of application the
        metarules do not carry individual names, which, as we will see, is the
        case when a set of metarules from a file is applied.}.

        The value of the parameter can be changed by choosing {\it Tools} 
        at the menu bar and then either {\it name mr output trees =
        input}  or {\it append rhs name to mr output trees}.

        
\item   For applying a metarule to all the trees of a buffer, click on the name
	of the buffer that contains the trees and proceed as above. The output
        will be a new buffer with all the output trees. The name of the new
        buffer will be the same as the input buffer prefixed by "MR-". The
        names of the trees follow the conventions above.

\end{itemize}

The other options concern application to files (instead of buffers). 
We will first define
the concepts of parallel, sequential and cumulative application of metarules. 
One metarule 
file can contain more than one metarule. The first two trees, i.e., the first
tree pair, form one metarule -- call it $mr_0$. Subsequent pairs in the
sequence of trees define additional metarules --- 
$mr_1$, $mr_2$, ..., $mr_n$.

\begin{itemize}
\item We say that a metarule file is applied in parallel to a tree 
(see Figure~\ref{parallel})
if each of the 
metarules is applied independently to the input generating its particular 
output trees\footnote{Remember that a metarule application generates as many 
output trees as the number of matches.}. We generalize the concept to the
application in parallel of a metarule file to a tree file (with possibly more 
than one tree), generating all the trees
as if each metarule in the metarule file was applied to each tree in the
input file.

\begin{figure}[htb]
\centerline{\psfig{figure=fig/parallel.ps,height=120pt}}
%\centerline{\psfig{figure=fig/parallel.ps,scale=60}}
%\centerline{\psfig{figure=fig/parallel.ps,width=330pt}}
\caption{Parallel application of metarules}
\label{parallel}
\end{figure}

\item We say that a metarule file $mr_0, mr_1, mr_2, ...,mr_n$ is applied in 
sequence to an input tree file 
(see Figure~\ref{sequential})
if we apply $mr_0$ to the trees of the input file, and
for each $0<i\leq n$ apply metarule $mr_i$ to the trees generated as a 
result of the application of $mr_{i-1}$.

\begin{figure}[htb]
\centerline{\psfig{figure=fig/sequential.ps,height=41pt}}
%\centerline{\psfig{figure=fig/sequential.ps,scale=60}}
\caption{Sequential application of metarules}
\label{sequential}
\end{figure}

\item Finally, the cumulative application is similar to the sequential, 
except that the input trees at each stage are passed to the output together
with the newly generated ones (see Figure~\ref{cumulative}).

\begin{figure}[htb]
\centerline{\psfig{figure=fig/cumulative.ps,height=53pt}}
%\centerline{\psfig{figure=fig/cumulative.ps,scale=60}}
\caption{Cumulative application of metarules}
\label{cumulative}
\end{figure}

\end{itemize}

Remember that in case of matching failure the output result is decided (as 
explained in subsection~\ref{output-gen}) either to be empty or to be the 
input tree. The reflex here of having the parameter set for copying the input
is that for the parallel application the output will have as many copies of
the input as matching failures. For the sequential case the decision is applied
at each level, and setting the parameter for copying, in a certain sense, 
guarantees that subsequent metarule applications will not break.
Due to its nature, and unlike the two other modes, the cumulative 
application is not affected by this parameter.

The options for application of metarules to files are available by clicking
on the menu item {\it Tools} and then choosing the appropriate function
from the following:

\begin{itemize}
\item   {\it Apply metarule to files:}  
        You will be prompted for the metarule file name which should contain
        one metarule\footnote{If the file contains more than 2 trees, the
        additional trees are ignored.}, and for input file names.  Each input
        file name {\bf inpfile} will be independently submitted to the
        application of the metarule generating an output file with the name
        {\bf MR-inpfile}.

\item   {\it Apply metarules in parallel to files:}
        You will be prompted for the metarules file name with one or more 
        metarules and for input file names.
        Each input file name {\bf inpfile} will be independently submitted to 
        the application of the metarules in parallel. For each parallel 
        application to a file {\bf inpfile} an output file with the 
        name    {\bf MRP-inpfile} will be generated.

\item   {\it Apply metarules in sequence to files:}  
        The interaction is as described for the application in parallel, 
        except that
        the application of the metarules are in sequence and that 
        the output files are prefixed by {\bf MRS-} instead of {\bf MRP-}.

\item   {\it Apply metarules cumulatively to files:}  
        The interaction is as described for the applications in parallel
        and in sequence, except that the mode of application is cumulative
        and that the output files are prefixed by {\bf MRC-}.
\end{itemize}

%For each case the user has the possibility of choosing what to do in the case
%of matching failure as discussed in the previous session.

The {\it Tools} menu also has entries to change the parameters of execution of
metarules. We saw earlier in this section how to set the parameter that
controls the name of the tree. Another parameter, explained in
Subsection~\ref{output-gen}, is the one that controls the output result on
matching failure. We can change it in the menu by selecting either {\it copy
input on mr matching failure} or {\it no output on mr matching failure}. Recall
that this parameter does not affect the cumulative mode.  The third parameter
controls comments generation. By choosing {\it append metarule comments} at
the {\it Tools} menu, the subsequent metarule applications will produce output
trees whose comments are the comments at the {\bf lhs} tree of the metarule
followed by the comments at {\bf inp}. Both parts are introduced by appropriate
headers, allowing the user to have a complete history of each tree. Choosing
{\it do not append metarule comments} makes the comments at the output trees
be exactly the same at the input tree. The third option, {\it clear comments on
metarule application}, causes the comment field to be left empty at the ouput
trees.

The default values for the tree parameters when XTAG is started are set:
to generate the output trees with the same name as the input; not to copy
the input tree in case of matching failure; and to add the metarule comments
to the output tree.

@


1.8
log
@wording, punctuation, etc. changes.
@
text
@d243 3
a245 3
\centering
\begin{tabular}{c}
\psfig{figure=ps/metarulealgo.eps,height=8.3in}
@


1.7
log
@changed from alltt macro to a ps figure for
the metarule matching algorithm description
@
text
@d7 5
a11 8
XTAG has now a collection of functions accessible from the user interface that
helps the user in the construction and maintenance of a tag tree-grammar.
This subsystem is based on the idea of metarules (\cite{becker93}).
Here our primary
purpose is to describe the facilities implemented under this 
metarule-based subsystem.
For a discussion of the metarules as a method for compact representation 
of the Lexicon see \cite{becker93} and \cite{srini94}.
d13 13
a25 14
The basic idea of using metarules is to take profit of the similarities of the
relations involving related pairs of XTAG elementary trees. 
For example, in the English grammar described in this technical report,
comparing the XTAG trees for the basic form and the 
wh-subject moved form, the relation between this two trees for transitive verbs
($\alpha nx_0Vnx_1$, $\alpha W_0nx_0Vnx_1$) is similar to the relation for the
intransitive verbs ($\alpha nx_0V$, $\alpha W_0nx_0V$) and also to the 
relation for the ditransitives ($\alpha nx_0Vnx_1nx_2$, 
$\alpha W_0nx_0Vnx_1nx_2$). Hence, instead of generating by hand the six trees 
mentioned above, a more natural and robust way would be generating by hand 
only the basic trees for the intransitive, transitive and ditransitive cases, 
and letting the wh-subject moved trees to be automatically generated by the
application of a unique transformation rule that would account exactly for
the identical relation involved in each of the three pairs above.
d31 3
a33 3
versions for the passive form. Depending on the degree of regularity that one
can find in the grammar being built, the reduction in the number of original
trees can be exponential. 
d35 1
d70 1
a70 1
        the metarule application\footnote{actually more than one output tree 
d72 1
a72 1
        input tree, as will be seen soon}.
d77 1
a77 1
We will use the terms ({\bf lhs}, {\bf rhs} and {\bf inp}) as introduced above
d87 2
a88 2
\item {\bf Constant Node:} Its name must not initiate by a question mark
        (`?' character). They are like we expect for names to be in normal
d95 1
a95 1
        subscript part can also be empty as in two of the above examples.
d97 10
a106 13
\item {\bf Non-Typed Variable Node:} Its name initiates by a question 
        mark (`?'), followed by a sequence of digits (i.e. a number) which 
        uniquely identifies the variable. Examples: ?1, ?3, 
        ?3452\footnote{Notice
        however that having the sole purpose of distinguishing between 
        variables, a number like the one in the last example 
        is not very likely
        to occur, and a metarule with more than 
        three thousand variables can give
        you a place in the Guinness TagBook of Records.}. We assume that
        there is no stem and no subscript in this names, i.e., `?' is just
        a meta-character to introduce a variable, and the number is the 
        variable identifier. 
d108 4
a111 4
\item {\bf Typed Variable Node:} Its name initiates by a question mark (`?')
        followed by a sequence of digits, but is additionally followed by
        a {\it type specifiers definition}. A {\it type specifiers definition}
        is a sequence of one or more {\it type specifier} separated by a slash
d113 10
a122 12
        name (like the constant nodes), except that the subscript can be also
        a question mark. Examples of typed variables are:
        $?1VP$ (a single type specifier with stem $VP$ and no subscript), 
        $?3NP_1/PP$ (two type specifiers, $NP_1$ and $PP$),
        $?1NP_?$ (one type specifier, $NP_?$ with undetermined subscript). 
        We'll see ahead that each type specifier represents an alternative
        for matching, and the presence of `?' in subscript position of a
        type specifier means that matching will only check for the stem
        \footnote{This is different from not having a subscript, the latter
	being
        interpreted as checking that the matching node at the
	input tree have no subscript}.
d134 1
a134 1
\item   A non-typed variable will be instantiated with a range of subtrees.
d145 1
a145 1
        substitution of occurences at {\bf rhs}.\\
d160 2
a161 2
In addition to return success or failure, the 
matching process also return the set of
d166 1
a166 1
The process of matching {\bf lhs} and {\bf inp} can be seen as a recursive 
d170 1
a170 1
follows we have used the term {\bf lhs} not only to refer to the whole tree 
d177 5
a181 6
The process described below returns 
at the end the set of matches (where an empty set means the same 
as failure). We first give one auxiliary definition, of valid Mapping, and
one recursive function Match, that matches lists of trees instead of trees,
and then define the process of matching two trees as a special case of
call to Match.
d190 2
a191 2
        list_{inp}$$,
i.e., the elements of $list_{inp}$ are split into sublists and assigned in 
d215 1
a215 1
        allowed to have some.}.\\
d223 1
a223 1
\item   if the type specifier doesn't have subscript, then 
d225 1
a225 1
\item   if the type specifier has a subscript different of `?', then 
d229 1
a229 1
        matching to be independent of the subscript}.
d232 1
a232 1
\item if $lhs_j$ is a non-typed variable node, then there's actually no
d261 1
a261 1
equations, which is the subject of the next subsection, we assume that only
d267 2
a268 2
alternative behaviors according to the value of a parameter\footnote{the
parameter is accessible at the Lisp interface by the name 
d272 1
a272 1
If the parameter is set to false, which is the {\it default} value, 
d275 2
a276 2
it is set to true, then the own {\bf inp} tree is copied to the 
output\footnote{As it will be seen in section \ref{access} the cumulative
d281 3
a283 3
given match, the output tree is generated by substituting in the {\bf rhs} tree
of the metarule the occurrences of variables by the material to which they have
been instantiated in the match. In the case of the typed-variable,
d286 1
a286 1
markers (foot, substitution, head, NA) are set at the output tree 
d294 6
a299 8
The case of the non-typed variable, not surpringly, is not so simple. 
In the output tree, this node
will be substituted by the subtree list that was associated to this variable,
in the same order, attaching to the parent of this non-typed variable node.
But remember, that some subtrees may have been removed from some of the trees
in this list, maybe entire elements of this list, due to the effect of the
children of the metavariable in {\bf lhs}. 
It is a 
d301 7
a307 8
tree has exactly the same number of children than the unique occurence of
this non-typed variable node in {\bf lhs}. Hence, when generating the output
tree, the subtrees at {\bf rhs}
will be inserted exactly at the points where subtrees were removed during 
matching, in a positional, one to one correspondance. If one wants any
of these cutting points to be left empty, as if the subtree has been removed
at the substitution points, the corresponding children at the {\bf rhs} tree
has to be labelled {\bf EMPTY}.
a308 4
For feature equations in the output trees see the next subsection. 
The generated comments deppend on a parameter setting as will be seen at the
end of section \ref{access}.

d313 5
a317 6
as XTAG is, accounting for features is essential. A metarule is not really
worth if it doesn't account for the proper change of feature 
equations\footnote{Notice that what is really important is not the features
themselves, but the feature equations that relate the feature values of nodes
of the same tree} from the input to the output tree. 
The aspects that have to be considered here are:
d336 1
a336 1
        (e.g. $+V.t:<trans>=+$)\footnote{Commutativity of equations is 
d344 1
a344 1
        To have this behaviout , the equation must be in {\bf lhs} preceded 
d351 1
a351 1
	(e.g. $\verb|^|V.b:<passive>=-$).
d357 1
a357 1
        Those equations must be in {\bf lhs} in raw form, i.e. neither preceded
d362 1
a362 1
        The equation is not required for matching but,
d375 1
a375 1
this directives were defined to be included in the {\bf lhs} tree as feature 
d386 1
a386 1
and {\it dummy1}, which may literally be the word ``dummy'' is required only
d395 1
a395 1
\item[{$|:$}] exchange {\it name1} with {\it name2} in all equations from
d398 1
a398 1
	(here, {\it name2} is also dummy)
d403 2
a404 2
be present for matching, matching will allways fail. Similarly replacing and
exchanging feature names will affect and be affected by the behaviour of
d408 2
a409 2
in the feature equations. Diversely of what we have done until here,
we will use the terms ``left'' and ``right hand
d411 1
a411 1
feature equation from a tree, {\bf NOT} to the sides of the metarule.
d413 2
a414 1
Non-typed variables don't play any role in the feature equations part.
d434 2
a435 2
introduced in the feature equations part. They have the same form of the
non-typed variables, i.e., a question mark followed by a number, and are used
d437 1
a437 1
$NP_r.b:<?2> = ?3$ appears in {\bf lhs}, this means, that all feature
d445 1
a445 3
henceforth they'll only match values identical to that they have been
instantiated. That's why we said ``a certain'' value/name, as opposed to
``any''.
d489 4
a492 5
Figure~\ref{wh} shows a metarule for general wh-movement of an NP. 
It can be applied to
generate trees with either subject or object NP moved. We show in 
Figure~\ref{prep}, the basic tree for the family Tnx0Vnx1Pnx2 and the three
wh-trees generated by the application of the rule.
d530 13
a542 17
We have defined conceptually a metarule as an ordered pair of trees. 
In the implementation
of the metarule subsystem it works the same: a metarule is a buffer with two
trees. The name of the metarule is the name of the buffer. The first tree that
appear in the main window under the metarule 
buffer is the {\it left hand side},
the next appearing below is the {\it right hand side}\footnote{Although a 
buffer is intended to implement the concept of a set (not a sequence) of trees
we take profit of the actual organization of the system to realize the
concept of (ordered) tree pair in the implementation.}. 
The positional approach allows us
to have naming freedom: the tree names
are irrelevant\footnote{so that even if we want to have mnemonic names 
resembling their distinct character - left or right hand side, - we have some
naming flexibility to call them e.g. {\it lhs23} or {\it lhs-passive}, ...}.
Since we can save buffers into text files, we can also talk about metarule
files. \\
d547 15
a561 18
\item   For applying it to a single input tree, click in the name of the
        tree in the main window, and choose the option 
        {\it apply metarule to tree}. 
        You will be prompted for the name of the metarule
        to apply to the tree
        which should be, as we mentioned before, the name of the buffer that
        contains the metarule trees. The output trees will be generated
        at the end of the buffer that contains the input tree. The names of
        the trees depend of a LISP parameter {\it *metarules-change-name* }.
        If the value of the parameter is {\bf false} --- the {\it default} 
        value --- then the new trees will have the same name as the input, 
        otherwise, the name of the input tree followed by a dash (`-') and
        the name of the right hand side of the tree\footnote{the reason why 
        we do not use the name of the metarule, i.e. the name of the buffer,
        is because in some forms of application the metarules do not
        carry individual names, which as we'll see soon is the case when 
	a set of
        metarules from a file is applied.}.
d568 5
a572 5
\item   For applying it to all the trees of a buffer, click in the name of the 
        buffer that contains the trees and proceed as above. The output will
        be a new buffer with all the output trees. The name of the new buffer
        will be the same as the input buffer prefixed by "MR-". The names of
        the trees follow the conventions above.
d577 1
a577 1
Lets first define
d581 1
a581 1
tree pair, form one metarule - lets call it $mr_0$. Subsequent pairs in the
d590 2
a591 2
output trees\footnote{remember a metarule application generates as many 
output trees as the number of matches}. We generalize the concept to the
d606 1
a606 1
sequence to a input tree file 
d620 1
a620 1
except that the input trees at each stage are by-passed to the output together
d632 2
a633 2
Remember that in case of matching failure the output result is decided as 
explained in subsection ~\ref{output-gen} either to be empty or to be the 
d636 1
a636 1
the input as matching failures. For the sequential case the decision apply
d638 1
a638 1
guarantees for the 'pipe' not to break.
d643 2
a644 2
at the menu item {\it Tools} and then choosing the appropriate function
among:
d648 6
a653 6
        You'll be prompted for the metarule file name
        which should contain one metarule\footnote{if it contains more than 
        2 trees, the additional trees are ignored}, and for input file names.
        Each input file name {\bf inpfile} will be independently submitted to 
        the application of the metarule generating an output file with the 
        name    {\bf MR-inpfile}.
d656 1
a656 1
        You'll be prompted for the metarules file name with one or more 
d678 16
a693 20
The {\it Tools} menu also has entries to change the parameters of execution
of metarules. We saw earlier in this section how to set the parameter the 
controls the name of the tree. Another parameter, explained in 
Subsection~\ref{output-gen} is the one that 
controls the output result on matching failure. We can change it in the menu  
by selecting
either {\it copy input on mr matching failure} or 
{\it no output on mr matching failure}. Recall that this parameter don't
affect the cumulative mode.
The third parameter controls comments generation. By choosing,
{\it append metarule comments} at the {\it Tools} menu, the subsequent
metarule applications will produce output trees whose comments
are the comments at the {\bf lhs}
tree of the metarule followed by the coments at {\bf inp}, both parts 
introduced by appropriate headers, allowing the user to have a complete
history of each tree. By choosing
{\it do not append metarule comments} we make the comments at the output
trees be exactly the same at the input tree. The third option, 
{\it clear comments on metarule application}, causes the comment field 
to be left empty at the ouput trees.
d696 1
a696 1
to generate the output trees with the same name as the input; to not to copy
@


1.6
log
@The appendix has been greatly modified. Some things we corrected: the algorithm
, the cummulative apl. picture, and lots of other things.
New features were documented, e.g: nodes labelled EMPTY below untyped variables,
commands to handle feature equations, negative reqrmt of feat. eq.,
proper handling of markers, changes in the interface, inclusion of conmments ...
@
text
@d251 8
a258 37
\begin{alltt}
   Function {\it{}Match} ({\it{}list}\(\sb{lhs}\), {\it{}list}\(\sb{inp}\))
       Let {\it{}MAPPINGS} be the list of all valid mappings from {\it{}list\(\sb{lhs}\)} to {\it{}list}\(\sb{inp}\)
       Make {\it{}MATCHES} = \(\emptyset\)
       For each mapping {\it{}Mapping} \(\in\) {\it{}MAPPINGS} do:
           Make {\it{}Matches} = \{\(\emptyset\)\}
           For each {\it{}j}, \(1\leq\){\it{}j}\(\leq\){\it{}l}, where {\it{}l}=length({\it{}list}\(\sb{lhs}\)), do: 
               If {\it{}lhs}\(\sb{j}\) is a constant node, then 
                  Let {\it{}children}\(\sb{lhs}\) be the list of children of {\it{}lhs}\(\sb{j}\) 
                      {\it{}inp}\(\sb{g(j)}\) be the single element in {\it{}Mapping}({\it{}lhs}\(\sb{j}\))
                      {\it{}children}\(\sb{inp}\) be the list of children of {\it{}inp}\(\sb{g(j)}\) 
                  Make {\it{}Matches} = \{{\it{}m}\(\cup\){\it{}m}\(\sb{j}\) \(\mid\) {\it{}m} \(\in\) {\it{}Matches} and 
                                          {\it{}m}\(\sb{j}\) \(\in\) {\it{}Match}({\it{}children}\(\sb{lhs}\), {\it{}children}\(\sb{inp}\))\}  
               If {\it{}lhs}\(\sb{j}\) is a typed variable node, then 
                  Let {\it{}children}\(\sb{lhs}\) be the list of children of {\it{}lhs}\(\sb{j}\)
                      {\it{}inp}\(\sb{g(j)}\) be the single element in {\it{}Mapping}({\it{}lhs}\(\sb{j}\))
                      {\it{}children}\(\sb{inp}\) be the list of children of {\it{}inp}\(\sb{g(j)}\)
                  Make {\it{}Matches} = \{ \{({\it{}lhs}\(\sb{j}\),{\it{}inp}\(\sb{g(j)}\))\}\(\cup\){\it{}m}\(\cup\){\it{}m}\(\sb{j}\) \(\mid\) {\it{}m} \(\in\) {\it{}Matches} and
                                         {\it{}m}\(\sb{j}\) \(\in\) {\it{}Match}({\it{}children}\(\sb{lhs}\), {\it{}children}\(\sb{inp}\)) \}
               If {\it{}lhs}\(\sb{j}\) is a non-typed variable node, then 
                  Let {\it{}children}\(\sb{lhs}\) be the list of children of {\it{}lhs}\(\sb{j}\)
                      {\it{}sl} be the number of nodes in {\it{}children}\(\sb{lhs}\)
                      {\it{}DESC} be the set of {\it{}sl}-sized lists given by:
                             {\it{}DESC} = \{[{\it{}di}\(\sb{1}\),{\it{}di}\(\sb{2}\),...,{\it{}di}\(\sb{sl}\)] \(\mid\)
                                       For every \(1\leq\){\it{}k}\(\leq\){\it{}sl}, {\it{}di}\(\sb{k}\) is a descendant
                                               of some node in {\it{}Mapping(lhs}\(\sb{j}\))\footnote{It's not necessary to be a proper descendant, i.e., {\it{}di}\(\sb{k}\) may be a node in {\it{}Mapping}({\it{}lhs}\(\sb{j}\))}
                             For every \(1<k\leq\){\it{}sl}, {\it{}di}\(\sb{k}\) is {\it{}to the right of} {\it{}di}\(\sb{k-1}\)\footnote{Recall that a node {\it{}n} is to the right of a node {\it{}m}, if {\it{}n} and {\it{}m} are not descendant of each other, and all the leaves dominated by {\it{}n} are to the right of the leaves dominated by {\it{}m}.}.
                      For every list {\it{}Desc} = [{\it{}di}\(\sb{1}\),{\it{}di}\(\sb{2}\),...,{\it{}di}\(\sb{sl}\)] \(\in\) {\it{}DESC} do: 
                          Let {\it{}Tree-Material} be the list of subtrees dominated 
                                   by the nodes in {\it{}Mapping}({\it{}lhs}\(\sb{j}\)), but, with the
                                   subtrees dominated by the nodes in {\it{}DESC}
                                   cut off from these trees 
                          Make {\it{}Matches} = \{ \{({\it{}lhs}\(\sb{j}\), {\it{}Tree-Material})\}\(\cup\){\it{}m}\(\cup\){\it{}m}\(\sb{j}\) \(\mid\)
                                  {\it{}m} \(\in\) {\it{}Matches} and {\it{}m}\(\sb{j}\) \(\in\) {\it{}Match}({\it{}children}\(\sb{lhs}\), {\it{}Desc})\} 
           Make {\it{}MATCHES} = {\it{}MATCHES} \(\cup\) {\it{}Matches}
       Return {\it{}MATCHES}
\end{alltt}
@


1.5
log
@added missing \}
@
text
@d5 1
d33 1
a33 1
passivization is applied to the tree different basic trees above, the 
d45 1
a45 1
Section 3 gives some
d47 3
a49 2
of metarule for the English grammar described in this
technical report and their application. Section 4 describes the access through 
d54 1
d127 4
a130 3
        \footnote{This is different from not having a subscript which is 
        interpreted as checking that the input tree have no subscript 
        for matching}.
d135 1
a135 1
a variable can be instantiated with different kinds of tree material:
d144 1
a144 1
        {\bf inp}. Hence, there will a node $n$ in {\bf inp}, with subtrees
d154 1
a154 1
        Notice still that the variable can
d168 2
a169 1
In addition to return success or failure, the process also return the set of
d209 1
a209 1
        single element, say, $rhs_{g(j)}$, and the two nodes must have the same
d211 2
a212 2
        if $lhs_j$ is NA, then $rhs_{g(j)}$ must be NA, 
        if $lhs_j$ has no markers, then $rhs_{g(j)}$ must have no markers, etc.
d214 2
a215 2
\item if $lhs_j$ is a type variable node, then $Mapping(lhs_j)$ must have a 
        single element, say, $rhs_{g(j)}$, and $rhs_{g(j)}$ must be 
d218 1
a218 1
        $rhs_{g(j)}$ is 
d221 1
a221 1
        present in $rhs_{g(j)}$\footnote{Notice that, unlike the case for the
d223 1
a223 1
        i.e., if $lhs_j$ has no marker, $rhs_{g(j)}$ is still 
d225 4
a228 4
        $rhs_{g(j)}$ is {\it type-compatible} with $lhs_j$ 
        if there is at least one of the alternative 
        type specifiers for the typed variable that satisfies 
        the conditions below. 
d231 1
a231 1
\item   $rhs_{g(j)}$ has the stem defined in the type specifier.
d233 1
a233 1
        $rhs_{g(j)}$ must have no subscript.
d235 1
a235 1
        $rhs_{g(j)}$ must have the same subscript as in the type specifier
d251 37
a287 2
\begin{tabbing}
012\=0123\=0123\=0123\=0123\=0123\=0123\=0123\=0123\=0123\=0123\=0123\=012\kill
a288 67
\> Function Match ($list_{lhs}$, $list_{rhs}$) \\
\>\> Let $MAPPINGS$ be the list of all valid mappings from $list_{lhs}$ to 
        $list_{rhs}$ \\

\>\> Make $MATCHES=\emptyset$ \\

\>\> For each mapping $Mapping\in MAPPINGS$ do: \\

\>\>\> Make $Matches=\{\emptyset \}$ \\

\>\>\> For each $j$, $1 \leq j \leq l$, where $l=length(list_{lhs})$, do: \\

\>\>\>\> if $lhs_j$ is a constant node, then \\

\>\>\>\>\> let \>$children_{lhs}$ be the list of children of $lhs_j$ \\
\>\>\>\>\>     \>$lhr_{g(j)}$ be the single element in $Mapping(lhs_j)$ \\
\>\>\>\>\>     \>$children_{rhs}$ be the list of children of $lhr_{g(j)}$ \\

\>\>\>\>\> Make $Matches=\{m\cup m_j\ \mid\  m\in Matches$ \\
\>\>\>\>\>\>\>\>\> $and\ m_j\in$ Match$(children_{lhs},\ children_{rhs})\}$ \\ 

\>\>\>\> if $lhs_j$ is a typed variable node, then \\

\>\>\>\>\> let \>$children_{lhs}$ be the list of children of $lhs_j$ \\
\>\>\>\>\>     \>$lhr_{g(j)}$ be the single element in $Mapping(lhs_j)$ \\
\>\>\>\>\>     \>$children_{rhs}$ be the list of children of $lhr_{g(j)}$ \\

\>\>\>\>\> Make $Matches=\{\{(lhs_j,lhr_{g(j)})\}\cup
        m\cup m_j\ \mid\  m\in Matches$ \\
\>\>\>\>\>\>\>\>\> $and\ m_j\in$ Match$(children_{lhs},\ children_{rhs})\}$ \\ 

\>\>\>\> if $lhs_j$ is a non-typed variable node, then \\

\>\>\>\>\> let \>$children_{lhs}$ be the list of children of $lhs_j$ \\
\>\>\>\>\> \> $sl$ be the number of nodes in $children_{lhs}$ \\

\>\>\>\>\>\> $DESC_s$ be the set of s-size lists given by: \\
\>\>\>\>\>\>\>\> $DESC_s=\{[dr_1,dr_2,...,dr_s]\ \mid\ $ \\
\>\>\>\>\>\>\>\>\>\> for every $1 \leq k \leq s$, $dr_k$ is a descendant \\
\>\>\>\>\>\>\>\>\>\>\>\> of
                        some node in $Mapping(lhs_j)\}$\footnote{it's not 
                necessary to be a proper descendant,
                i.e., $dr_k$ may be a node in $Mapping(lhs_j)$}\\
\>\>\>\>\>\>\>\>\>\> for every $1 < k \leq s$, $dr_l$ is {\it to the right of}
                        $dr_{k-1}$\footnote{recall that a node 
$n$ is to the right of a node $m$, if $n$ and $m$ are not descendant of each
other, and all the leaves dominated by $n$ are to the right of the leaves
dominated by $m$.}.\\

\>\>\>\>\>\> For every list $Desc=[dr_1,dr_2,...,dr_s] \in DESC_s$ do: \\

\>\>\>\>\>\>\> Let Tree-Material be the list of subtrees dominated \\
\>\>\>\>\>\>\>\>\> by the nodes in $Mapping(lhs_j)$, but, with the \\
\>\>\>\>\>\>\>\>\> subtrees dominated by the nodes in $DESC_s$ \\
\>\>\>\>\>\>\>\>\> cut out from these trees \\

\>\>\>\>\>\>\> Make $Matches=\{\{(lhs_j,\ Tree-Struct)\}\ \cup 
        m\cup m_j\ \mid$ \\
\>\>\>\>\>\>\>\>\> $m\in Matches\ and\ 
        m_j\in$ Match$(children_{lhs},\ Desc)\}$ \\ 

\>\>\> Make $MATCHES\ =\ MATCHES\ \cup\ Matches$ \\

\>\> Return $MATCHES$

\end{tabbing}

d307 3
a309 1
{\it XTAG::*metarules-copy-unmatched-trees*}}. 
d313 3
a315 1
it is set to true, then the own {\bf inp} tree is copied to the output.
d321 10
a330 7
been instantiated in the match. The case of the typed-variable is simple. 
The name of the variable is just substituted by the name of the node to which
it has been instantiated from {\bf inp}. A very important detail is that the
marker (foot, substitution, head, NA, or none) at the output tree node comes 
from what is specified in the {\bf rhs} node, which can be different of the
marker at the variable node in {\bf inp} and of the associated node from 
{\bf inp}.
d334 2
a335 2
will be substituted by the subtree list that was associated to this node,
in the same other, attaching to the parent of this non-typed variable node.
d345 4
a348 1
matching, in a positional, one to one correspondance.
d350 3
a352 5
For feature equations in the output trees see the
next subsection. The comments at the output are the comments at the {\bf lhs}
tree of the metarule followed by the coments at {\bf inp}, both parts 
introduced by appropriate headers, allowing the user to have a complete
history of each tree.
d373 2
a374 4
Based on the possible combinations of these requirements we partition the 
feature equations into the following five classes\footnote{This 
classification is really a partition, i.e., no equation may be conceptually
in more than one class at the same time.}: 
d377 3
a379 3
\item   {\it Require \& Retain:} Feature equations in this class
        are required to be in {\bf inp} in order for matching to succeed.
        Upon matching, these equations will be copied to the output tree.
d390 2
a391 1
        Those equations must be in {\bf lhs} preceded by minus character
d394 5
d416 1
a416 1
        case it is the right hand side).
d419 41
d461 3
a463 2
{\bf rhs}. They are intended to represent the nodes of the input tree to which
they have been instantiated. For each resulting match 
d480 13
a492 5
non-typed variables, i.e. quotation mark, followed by a number, and are used
in the place of feature values and feature names. Hence, if the equation
$?NP_?.b:<?2> = ?3$ appears in {\bf lhs}, this means, that all feature
equations of {\bf inp} that match a bottom attribute of some $NP$ to any 
feature value (but not to a feature path) will not be copied to the output.
d500 1
d510 2
a511 2
\framebox{\psfig{figure=fig/lhs-wh-subj.ps,scale=45}} &
\framebox{\psfig{figure=fig/rhs-wh-subj.ps,scale=45}} \\
d527 2
a528 2
\framebox{\psfig{figure=fig/lhs-wh-obj.ps,scale=45}} &
\framebox{\psfig{figure=fig/rhs-wh-obj.ps,scale=45}} \\
d539 1
a539 1
Figure~\ref{prep}, the basic tree for the family Tnx0Vnx1Pnx2 and the tree
d545 2
a546 2
\framebox{\psfig{figure=fig/lhs-wh.ps,scale=45}} &
\framebox{\psfig{figure=fig/rhs-wh.ps,scale=45}} \\
d557 2
a558 2
\framebox{\psfig{figure=fig/prep.ps,scale=45}} &
\framebox{\psfig{figure=fig/prep1.ps,scale=45}} \\
d561 2
a562 2
\framebox{\psfig{figure=fig/prep2.ps,scale=45}} &
\framebox{\psfig{figure=fig/prep3.ps,scale=45}} \\
d571 1
d576 1
a576 1
modes to input tree files.
d593 2
a594 2
Since we can save buffers into text files, we can talk also about metarule
files.
d614 2
a615 1
        carry individual names, as we'll see soon is the case when a set of
d653 1
a653 1
\centerline{\psfig{figure=fig/parallel.ps,scale=70}}
d668 1
a668 1
\centerline{\psfig{figure=fig/sequential.ps,scale=70}}
d679 1
a679 1
\centerline{\psfig{figure=fig/cumulative.ps,scale=70}}
d694 1
a694 1
Due to its nature and unlike the two other modes, the cumulative 
d733 6
a738 4
Finally still under the {\it Tools} menu we can change the setting of the 
parameter that controls the output result on matching failure 
(see Subsection~\ref{output-gen})
by choosing
d740 19
a758 1
{\it no output on mr matching failure}.
@


1.4
log
@minor typo
@
text
@d289 1
a289 1
                        some node in $Mapping(lhs_j)$\footnote{it's not 
@


1.3
log
@changed Xtag to XTAG
@
text
@d292 1
a292 1
\>\>\>\>\>\>\>\>\>\> for every $1 < k \leq s$, $dr_l$ is {\it to the rigth of}
@


1.2
log
@minor typos
@
text
@d6 1
a6 1
Xtag has now a collection of functions accessible from the user interface that
d16 1
a16 1
relations involving related pairs of Xtag elementary trees. 
d18 1
a18 1
comparing the Xtag trees for the basic form and the 
d43 1
a43 1
In the next section we define a metarule in Xtag. 
d51 1
a51 1
\section{The definition of a metarule in Xtag}
d54 2
a55 2
In Xtags the grammar 
rules are lexicalized trees. Hence an Xtag metarule {\bf mr} 
d89 1
a89 1
        Xtag trees; for instance, {\bf inp} is expected to have only constant
d115 1
a115 1
        (`/'). A {\it type specifier} has the same form of a regular Xtag node
d334 1
a334 1
{\it Xtag::*metarules-copy-unmatched-trees*}}. 
@


1.1
log
@Initial revision
@
text
@d60 2
a61 2
	i.e., it is intended to present a specific pattern of tree to look for
	in the trees submitted to the application of the metarule.
d64 2
a65 2
	step is to verify if the input tree matches the pattern specified by
	the {\bf lhs}. If there is no match, the application {\it fails}.
d68 5
a72 5
	with {\bf lhs}) the transformation that will be done in {\bf inp},
	in case of successful matching, thus generating the output tree of
	the metarule application\footnote{actually more than one output tree 
	can be generated from the successful application of a rule to an 
	input tree, as will be seen soon}.
d88 8
a95 8
	('?' character). They are like we expect for names to be in normal
	Xtag trees; for instance, {\bf inp} is expected to have only constant
	nodes. Some examples of constant nodes are $NP$, $V$, $NP_0$, $NP_1$,
	$S_r$. We will call the two parts that compose such names
	the {\it stem} and the {\it subscript}.
	In the examples above  $NP$, $V$ and $S$ are stems and 
	$0$, $1$, $r$ are subscripts. Notice that the
	subscript part can also be empty as in two of the above examples.
d98 12
a109 12
	mark ('?'), followed by a sequence of digits (i.e. a number) which 
	uniquely identifies the variable. Examples: ?1, ?3, 
	?3452\footnote{Notice
	however that having the sole purpose of distinguishing between 
	variables, a number like the one in the last example 
	is not very likely
	to occur, and a metarule with more than 
	three thousand variables can give
	you a place in the Guinness TagBook of Records.}. We assume that
	there is no stem and no subscript in this names, i.e., '?' is just
	a meta-character to introduce a variable, and the number is the 
	variable identifier. 
d111 16
a126 16
\item {\bf Typed Variable Node:} Its name initiates by a question mark ('?')
	followed by a sequence of digits, but is additionally followed by
	a {\it type specifiers definition}. A {\it type specifiers definition}
	is a sequence of one or more {\it type specifier} separated by a slash
	('/'). A {\it type specifier} has the same form of a regular Xtag node
	name (like the constant nodes), except that the subscript can be also
	a question mark. Examples of typed variables are:
	$?1VP$ (a single type specifier with stem $VP$ and no subscript), 
	$?3NP_1/PP$ (two type specifiers, $NP_1$ and $PP$),
	$?1NP_?$ (one type specifier, $NP_?$ with undetermined subscript). 
	We'll see ahead that each type specifier represents an alternative
	for matching, and the presence of '?' in subscript position of a
	type specifier means that matching will only check for the stem
	\footnote{This is different from not having a subscript which is 
	interpreted as checking that the input tree have no subscript 
	for matching}.
d129 3
a131 4
During the process of matching, variables are associated 
(we use the term {\it instantiated}) with 'tree material'.
According to its class a variable can be instantiated with different kinds of
tree material:
d134 3
a136 3
\item	A typed variable will be instantiated with exactly one node of
	the input tree, which is in accordance to one of its type specifiers
	(The full rule is in the following subsection). 
d138 14
a151 14
\item	A non-typed variable will be instantiated with a range of subtrees.
	These subtrees will be taken from one of the nodes of the input tree
	{\bf inp}. Hence, there will a node $n$ in {\bf inp}, with subtrees
	$n.t_1$, $n.t_2$, ..., $n.t_k$, in this order, where the variable
	will be instantiated with some subsequence of these subtrees 
	(e.g., $n.t_2$, $n.t_3$, $n.t_4$). Note however, that some of these
	subtrees, may be incomplete, i.e., they may not go all the way to the 
	bottom leaves. Entire subtrees may be removed. Actually for each
	child of the non-typed variable node, one subtree that matches this
	child subtree will be removed from some of the $n.t_i$(maybe an entire
	$n.t_i$), leaving in place a mark for inserting material during the
	substitution of occurences at {\bf rhs}.\\
	Notice still that the variable can
	be instantiated with a single tree and even with no tree. 
d194 1
a194 1
	list_{inp}$$,
d204 4
a207 4
	single element, say, $rhs_{g(j)}$, and the two nodes must have the same
	name and agree on the markers (foot, substitution, head and NA), i.e.,
	if $lhs_j$ is NA, then $rhs_{g(j)}$ must be NA, 
	if $lhs_j$ has no markers, then $rhs_{g(j)}$ must have no markers, etc.
d210 14
a223 14
	single element, say, $rhs_{g(j)}$, and $rhs_{g(j)}$ must be 
	{\it marker-compatible} and 
	{\it type-compatible} with $lhs_j$. \\
	$rhs_{g(j)}$ is 
	{\it marker-compatible} with $lhs_j$ if any marker
	 (foot, substitution, head and NA) present in $lhs_j$ is also
	present in $rhs_{g(j)}$\footnote{Notice that, unlike the case for the
	constant node, the inverse is not required, 
	i.e., if $lhs_j$ has no marker, $rhs_{g(j)}$ is still 
	allowed to have some.}.\\
	$rhs_{g(j)}$ is {\it type-compatible} with $lhs_j$ 
	if there is at least one of the alternative 
	type specifiers for the typed variable that satisfies 
	the conditions below. 
d226 8
a233 8
\item	$rhs_{g(j)}$ has the stem defined in the type specifier.
\item	if the type specifier doesn't have subscript, then 
	$rhs_{g(j)}$ must have no subscript.
\item	if the type specifier has a subscript different of '?', then 
	$rhs_{g(j)}$ must have the same subscript as in the type specifier
	\footnote{If the type specifier has a '?' subscript, there is no
	restriction, and that is exactly its function: to allow for the 
	matching to be independent of the subscript}.
d237 2
a238 2
	requirement: $Mapping(lhs_j)$ may have any length and even be 
	empty.
d240 1
a240 1
	
d251 1
a251 1
	$list_{rhs}$ \\
d277 1
a277 1
	m\cup m_j\ \mid\  m\in Matches$ \\
d289 3
a291 3
			some node in $Mapping(lhs_j)$\footnote{it's not 
		necessary to be a proper descendant,
	        i.e., $dr_k$ may be a node in $Mapping(lhs_j)$}\\
d293 1
a293 1
			$dr_{k-1}$\footnote{recall that a node 
d306 1
a306 1
	m\cup m_j\ \mid$ \\
d308 1
a308 1
	m_j\in$ Match$(children_{lhs},\ Desc)\}$ \\ 
d385 2
a386 2
\item	Which feature equations should be required to be present in {\bf inp}
	in order for the match to succeed.
d388 2
a389 2
\item	Which feature equations should be generated in the output tree as a 
	function of the feature equations in the input tree.
d398 15
a412 15
\item	{\it Require \& Retain:} Feature equations in this class
	are required to be in {\bf inp} in order for matching to succeed.
	Upon matching, these equations will be copied to the output tree.
	To achieve this behaviour, the equation must be placed in 
	the {\bf lhs} tree of the metarule preceded by a plus character
	(e.g. $+V.t:<trans>=+$)\footnote{Commutativity of equations is 
	accounted for in the system. Hence an equation $x=y$ can also be
	specified as $y=x$. Associativity is not accounted for and its need by
	an user is viewed as indicating misspecification at the input trees.}
	
\item	{\it Require \& Don't Copy:} The equation is required to be in 
	{\bf inp}
	for matching, but should not be copied to the output tree.
	Those equations must be in {\bf lhs} preceded by minus character
	(e.g. $-NP_1:<case>=acc$).
d414 7
a420 7
\item	{\it Optional \& Don't Copy:} 
	The equation is not required for matching,
	but we have to make sure not to copy it to the output tree set of
	equations, regardless of it being present or not in {\bf inp}.
	Those equations must be in {\bf lhs} in raw form, i.e. neither preceded
	by a plus nor minus character
	(e.g. $S_r.b:<perfect>=VP.t:<perfect>$).
d422 5
a426 5
\item	{\it Optional \& Retain:} 
	The equation is not required for matching but,
	in case it is found in {\bf inp} it must be copied to the output tree.
	This is the {\it default} case, and hence these equations should not be
	present in the metarule specification.
d428 4
a431 4
\item	{\it Add:} The equation is not required for matching but we want it to
	be put in the output tree anyway.
	These equations are placed in raw form in the {\bf rhs} (notice in this
	case it is the right hand side).
d440 2
a441 2
\item	The (typed) variables in the equations at {\bf lhs} and {\bf rhs} are 
	substituted by the names of the nodes they have been instantiated to.
d443 2
a444 2
\item	The requirements concerning feature equations are checked, according
	to the above rules.
d446 3
a448 3
\item	If the match survives feature equation checking, the proper output tree
	is generated, according to Section~\ref{output-gen} and to the 
	rules described above for the feature equations.
d562 17
a578 17
\item	For applying it to a single input tree, click in the name of the
	tree in the main window, and choose the option 
	{\it apply metarule to tree}. 
	You will be prompted for the name of the metarule
	to apply to the tree
	which should be, as we mentioned before, the name of the buffer that
	contains the metarule trees. The output trees will be generated
	at the end of the buffer that contains the input tree. The names of
	the trees depend of a LISP parameter {\it *metarules-change-name* }.
	If the value of the parameter is {\bf false} --- the {\it default} 
	value --- then the new trees will have the same name as the input, 
	otherwise, the name of the input tree followed by a dash ('-') and
	the name of the right hand side of the tree\footnote{the reason why 
	we do not use the name of the metarule, i.e. the name of the buffer,
	is because in some forms of application the metarules do not
	carry individual names, as we'll see soon is the case when a set of
	metarules from a file is applied.}.
d580 3
a582 3
	The value of the parameter can be changed by choosing {\it Tools} 
	at the menu bar and then either {\it name mr output trees =
	input}  or {\it append rhs name to mr output trees}.
d584 6
a589 6
	
\item	For applying it to all the trees of a buffer, click in the name of the 
	buffer that contains the trees and proceed as above. The output will
	be a new buffer with all the output trees. The name of the new buffer
	will be the same as the input buffer prefixed by "MR-". The names of
	the trees follow the conventions above.
d664 7
a670 7
\item	{\it Apply metarule to files:}  
	You'll be prompted for the metarule file name
	which should contain one metarule\footnote{if it contains more than 
	2 trees, the additional trees are ignored}, and for input file names.
	Each input file name {\bf inpfile} will be independently submitted to 
	the application of the metarule generating an output file with the 
	name	{\bf MR-inpfile}.
d672 7
a678 7
\item	{\it Apply metarules in parallel to files:}
	You'll be prompted for the metarules file name with one or more 
	metarules and for input file names.
	Each input file name {\bf inpfile} will be independently submitted to 
	the application of the metarules in parallel. For each parallel 
	application to a file {\bf inpfile} an output file with the 
	name	{\bf MRP-inpfile} will be generated.
d680 5
a684 5
\item	{\it Apply metarules in sequence to files:}  
	The interaction is as described for the application in parallel, 
	except that
	the application of the metarules are in sequence and that 
	the output files are prefixed by {\bf MRS-} instead of {\bf MRP-}.
d686 4
a689 4
\item	{\it Apply metarules cumulatively to files:}  
	The interaction is as described for the applications in parallel
	and in sequence, except that the mode of application is cumulative
	and that the output files are prefixed by {\bf MRC-}.
@
