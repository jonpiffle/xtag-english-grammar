\chapter{Metarules}
\label{metarules}

\section{Introduction}
\label{introduction}

XTAG has now a collection of functions accessible from the user interface that
helps the user in the construction and maintenance of a tag tree-grammar.
This subsystem is based on the idea of metarules (\cite{becker93}).
Here our primary
purpose is to describe the facilities implemented under this 
metarule-based subsystem.
For a discussion of the metarules as a method for compact representation 
of the Lexicon see \cite{becker93} and \cite{srini94}.

The basic idea of using metarules is to take profit of the similarities of the
relations involving related pairs of XTAG elementary trees. 
For example, in the English grammar described in this technical report,
comparing the XTAG trees for the basic form and the 
wh-subject moved form, the relation between this two trees for transitive verbs
($\alpha nx_0Vnx_1$, $\alpha W_0nx_0Vnx_1$) is similar to the relation for the
intransitive verbs ($\alpha nx_0V$, $\alpha W_0nx_0V$) and also to the 
relation for the ditransitives ($\alpha nx_0Vnx_1nx_2$, 
$\alpha W_0nx_0Vnx_1nx_2$). Hence, instead of generating by hand the six trees 
mentioned above, a more natural and robust way would be generating by hand 
only the basic trees for the intransitive, transitive and ditransitive cases, 
and letting the wh-subject moved trees to be automatically generated by the
application of a unique transformation rule that would account exactly for
the identical relation involved in each of the three pairs above.

Notice that the degree of generalization can be much higher than it might be
thought in principle from the above paragraph. For example, once a rule for
passivization is applied to the three different basic trees above, the 
wh-subject moved rule could be again applied to generate the wh-moved subject
versions for the passive form. Depending on the degree of regularity that one
can find in the grammar being built, the reduction in the number of original
trees can be exponential. 

We still make here a point that the reduction of effort in grammar construction
is not the only advantage of the approach. Robustness, 
reliability and maintainability of the grammar achieved by the use of  
metarules are equally or even more important.

In the next section we define a metarule in XTAG. 
Section \ref{examples} gives some
linguistically motivated examples
of metarules for the English grammar described in this
technical report and their application. Section \ref{access} 
describes the access through 
the user interface.
%Section 3 describes the access through the user interface.

\section{The definition of a metarule in XTAG}
\label{definition}

A metarule specifies a rule for transforming grammar rules into grammar rules. 
In XTAG the grammar 
rules are lexicalized trees. Hence an XTAG metarule {\bf mr} 
is a pair {\bf (lhs, rhs)} of XTAG trees, where:

\begin{itemize}
\item {\bf lhs}, the {\it left-hand side} of the metarule, is a pattern tree,
        i.e., it is intended to present a specific pattern of tree to look for
        in the trees submitted to the application of the metarule.

\item When a metarule {\bf mr} is applied to an input tree {\bf inp}, the first
        step is to verify if the input tree matches the pattern specified by
        the {\bf lhs}. If there is no match, the application {\it fails}.

\item {\bf rhs}, the {\it right-hand side} of the metarule, specifies (together
        with {\bf lhs}) the transformation that will be done in {\bf inp},
        in case of successful matching, thus generating the output tree of
        the metarule application\footnote{actually more than one output tree 
        can be generated from the successful application of a rule to an 
        input tree, as will be seen soon}.
\end{itemize}
 
\subsection{Node names, variable instantiation, and matches}

We will use the terms ({\bf lhs}, {\bf rhs} and {\bf inp}) as introduced above
to refer to the parts of a generic metarule being applied to an input tree. 

The nodes at {\bf lhs} can take three 
different forms: a constant node, a typed variable node, and a non-typed 
variable node. The naming conventions for these different classes of nodes is 
given below.

\begin{itemize}

\item {\bf Constant Node:} Its name must not initiate by a question mark
        (`?' character). They are like we expect for names to be in normal
        XTAG trees; for instance, {\bf inp} is expected to have only constant
        nodes. Some examples of constant nodes are $NP$, $V$, $NP_0$, $NP_1$,
        $S_r$. We will call the two parts that compose such names
        the {\it stem} and the {\it subscript}.
        In the examples above  $NP$, $V$ and $S$ are stems and 
        $0$, $1$, $r$ are subscripts. Notice that the
        subscript part can also be empty as in two of the above examples.

\item {\bf Non-Typed Variable Node:} Its name initiates by a question 
        mark (`?'), followed by a sequence of digits (i.e. a number) which 
        uniquely identifies the variable. Examples: ?1, ?3, 
        ?3452\footnote{Notice
        however that having the sole purpose of distinguishing between 
        variables, a number like the one in the last example 
        is not very likely
        to occur, and a metarule with more than 
        three thousand variables can give
        you a place in the Guinness TagBook of Records.}. We assume that
        there is no stem and no subscript in this names, i.e., `?' is just
        a meta-character to introduce a variable, and the number is the 
        variable identifier. 

\item {\bf Typed Variable Node:} Its name initiates by a question mark (`?')
        followed by a sequence of digits, but is additionally followed by
        a {\it type specifiers definition}. A {\it type specifiers definition}
        is a sequence of one or more {\it type specifier} separated by a slash
        (`/'). A {\it type specifier} has the same form of a regular XTAG node
        name (like the constant nodes), except that the subscript can be also
        a question mark. Examples of typed variables are:
        $?1VP$ (a single type specifier with stem $VP$ and no subscript), 
        $?3NP_1/PP$ (two type specifiers, $NP_1$ and $PP$),
        $?1NP_?$ (one type specifier, $NP_?$ with undetermined subscript). 
        We'll see ahead that each type specifier represents an alternative
        for matching, and the presence of `?' in subscript position of a
        type specifier means that matching will only check for the stem
        \footnote{This is different from not having a subscript, the latter
	being
        interpreted as checking that the matching node at the
	input tree have no subscript}.
\end{itemize}

During the process of matching, variables are associated (we use the
term {\it instantiated}) with `tree material'.  According to its class
a variable may be instantiated with different kinds of tree material:

\begin{itemize}
\item   A typed variable will be instantiated with exactly one node of
        the input tree, which is in accordance to one of its type specifiers
        (The full rule is in the following subsection). 

\item   A non-typed variable will be instantiated with a range of subtrees.
        These subtrees will be taken from one of the nodes of the input tree
        {\bf inp}. Hence, there will be a node $n$ in {\bf inp}, with subtrees
        $n.t_1$, $n.t_2$, ..., $n.t_k$, in this order, where the variable
        will be instantiated with some subsequence of these subtrees 
        (e.g., $n.t_2$, $n.t_3$, $n.t_4$). Note however, that some of these
        subtrees, may be incomplete, i.e., they may not go all the way to the 
        bottom leaves. Entire subtrees may be removed. Actually for each
        child of the non-typed variable node, one subtree that matches this
        child subtree will be removed from some of the $n.t_i$(maybe an entire
        $n.t_i$), leaving in place a mark for inserting material during the
        substitution of occurences at {\bf rhs}.\\
        Notice still that the variable may
        be instantiated with a single tree and even with no tree. 

\end{itemize} 

We define a {\it match} to be a complete instantiation of all variables 
appearing in the metarule. In the process of matching, there may be several
possible ways of instantiating the set of variables of the metarule, i.e.,
several possible matches. This is due to the presence of non-typed variables.

Now, we are ready to define what we mean by a successful matching. The process
of matching is {\it successful} 
if the number of possible matches is greater then 0.
When there is no possible match the process is said to {\it fail}.
In addition to return success or failure, the 
matching process also return the set of
all possible {\it matches}, which will be used for generating the output.

\subsection{Structural Matching}

The process of matching {\bf lhs} and {\bf inp} can be seen as a recursive 
procedure for matching trees, starting at their roots and proceeding in a 
top-down style along with their subtrees. 
In the explanation of this process that 
follows we have used the term {\bf lhs} not only to refer to the whole tree 
that contains the pattern 
but to any of its subtrees that is being considered in a 
given recursive step. The same applies to {\bf inp}. 
By now we ignore feature equations,
which will be accounted for in the next subsection.

The process described below returns 
at the end the set of matches (where an empty set means the same 
as failure). We first give one auxiliary definition, of valid Mapping, and
one recursive function Match, that matches lists of trees instead of trees,
and then define the process of matching two trees as a special case of
call to Match.

Given a list $list_{lhs}=[lhs_1, lhs_2, ..., lhs_l]$ of nodes of {\bf lhs}
and a list $list_{inp}=[inp_1, inp_2, ..., inp_i]$ of nodes of {\bf inp},
we define a {\it mapping} from $list_{lhs}$ to $list_{inp}$ to be a function
$Mapping$,
that for each element of $list_{lhs}$ assigns a list of elements of 
$list_{inp}$, defined by the following condition:
$$concatenation\ (Mapping(lhs_1),\ Mapping(lhs_2),\ ...,\ Mapping(lhs_l))\ =\ 
        list_{inp}$$,
i.e., the elements of $list_{inp}$ are split into sublists and assigned in 
order of appearance in the list to the elements of $list_{lhs}$.

We say that a mapping is a {\it valid mapping} if for all $j$, $1\leq j \leq l$
(where $l$ is the length of $list_{lhs}$), the following restrictions apply:

\begin{enumerate}

\item if $lhs_j$ is a constant node, then $Mapping(lhs_j)$ must have a 
        single element, say, $inp_{g(j)}$, and the two nodes must have the same
        name and agree on the markers (foot, substitution, head and NA), i.e.,
        if $lhs_j$ is NA, then $inp_{g(j)}$ must be NA, 
        if $lhs_j$ has no markers, then $inp_{g(j)}$ must have no markers, etc.

\item if $lhs_j$ is a typed variable node, then $Mapping(lhs_j)$ must have a 
        single element, say, $inp_{g(j)}$, and $inp_{g(j)}$ must be 
        {\it marker-compatible} and 
        {\it type-compatible} with $lhs_j$. \\
        $inp_{g(j)}$ is 
        {\it marker-compatible} with $lhs_j$ if any marker
         (foot, substitution, head and NA) present in $lhs_j$ is also
        present in $inp_{g(j)}$\footnote{Notice that, unlike the case for the
        constant node, the inverse is not required, 
        i.e., if $lhs_j$ has no marker, $inp_{g(j)}$ is still 
        allowed to have some.}.\\
        $inp_{g(j)}$ is {\it type-compatible} with $lhs_j$ 
        if at least one of the alternative 
        type specifiers for the typed variable $lhs_j$ satisfies 
        the conditions below:

\begin{itemize}
\item   $inp_{g(j)}$ has the stem defined in the type specifier.
\item   if the type specifier doesn't have subscript, then 
        $inp_{g(j)}$ must have no subscript.
\item   if the type specifier has a subscript different of `?', then 
        $inp_{g(j)}$ must have the same subscript as in the type specifier
        \footnote{If the type specifier has a `?' subscript, there is no
        restriction, and that is exactly its function: to allow for the 
        matching to be independent of the subscript}.
\end{itemize}

\item if $lhs_j$ is a non-typed variable node, then there's actually no
        requirement: $Mapping(lhs_j)$ may have any length and even be 
        empty.
\end{enumerate}
        
The following algorithm, Match, takes as input a list of nodes of {\bf lhs}
and a list of nodes of {\bf inp}, and returns the set of possible matches
generated in the attempt of match this two lists. If the result is an empty
set, this means that the matching failed.

\begin{alltt}
   Function {\it{}Match} ({\it{}list}\(\sb{lhs}\), {\it{}list}\(\sb{inp}\))
       Let {\it{}MAPPINGS} be the list of all valid mappings from {\it{}list\(\sb{lhs}\)} to {\it{}list}\(\sb{inp}\)
       Make {\it{}MATCHES} = \(\emptyset\)
       For each mapping {\it{}Mapping} \(\in\) {\it{}MAPPINGS} do:
           Make {\it{}Matches} = \{\(\emptyset\)\}
           For each {\it{}j}, \(1\leq\){\it{}j}\(\leq\){\it{}l}, where {\it{}l}=length({\it{}list}\(\sb{lhs}\)), do: 
               If {\it{}lhs}\(\sb{j}\) is a constant node, then 
                  Let {\it{}children}\(\sb{lhs}\) be the list of children of {\it{}lhs}\(\sb{j}\) 
                      {\it{}inp}\(\sb{g(j)}\) be the single element in {\it{}Mapping}({\it{}lhs}\(\sb{j}\))
                      {\it{}children}\(\sb{inp}\) be the list of children of {\it{}inp}\(\sb{g(j)}\) 
                  Make {\it{}Matches} = \{{\it{}m}\(\cup\){\it{}m}\(\sb{j}\) \(\mid\) {\it{}m} \(\in\) {\it{}Matches} and 
                                          {\it{}m}\(\sb{j}\) \(\in\) {\it{}Match}({\it{}children}\(\sb{lhs}\), {\it{}children}\(\sb{inp}\))\}  
               If {\it{}lhs}\(\sb{j}\) is a typed variable node, then 
                  Let {\it{}children}\(\sb{lhs}\) be the list of children of {\it{}lhs}\(\sb{j}\)
                      {\it{}inp}\(\sb{g(j)}\) be the single element in {\it{}Mapping}({\it{}lhs}\(\sb{j}\))
                      {\it{}children}\(\sb{inp}\) be the list of children of {\it{}inp}\(\sb{g(j)}\)
                  Make {\it{}Matches} = \{ \{({\it{}lhs}\(\sb{j}\),{\it{}inp}\(\sb{g(j)}\))\}\(\cup\){\it{}m}\(\cup\){\it{}m}\(\sb{j}\) \(\mid\) {\it{}m} \(\in\) {\it{}Matches} and
                                         {\it{}m}\(\sb{j}\) \(\in\) {\it{}Match}({\it{}children}\(\sb{lhs}\), {\it{}children}\(\sb{inp}\)) \}
               If {\it{}lhs}\(\sb{j}\) is a non-typed variable node, then 
                  Let {\it{}children}\(\sb{lhs}\) be the list of children of {\it{}lhs}\(\sb{j}\)
                      {\it{}sl} be the number of nodes in {\it{}children}\(\sb{lhs}\)
                      {\it{}DESC} be the set of {\it{}sl}-sized lists given by:
                             {\it{}DESC} = \{[{\it{}di}\(\sb{1}\),{\it{}di}\(\sb{2}\),...,{\it{}di}\(\sb{sl}\)] \(\mid\)
                                       For every \(1\leq\){\it{}k}\(\leq\){\it{}sl}, {\it{}di}\(\sb{k}\) is a descendant
                                               of some node in {\it{}Mapping(lhs}\(\sb{j}\))\footnote{It's not necessary to be a proper descendant, i.e., {\it{}di}\(\sb{k}\) may be a node in {\it{}Mapping}({\it{}lhs}\(\sb{j}\))}
                             For every \(1<k\leq\){\it{}sl}, {\it{}di}\(\sb{k}\) is {\it{}to the right of} {\it{}di}\(\sb{k-1}\)\footnote{Recall that a node {\it{}n} is to the right of a node {\it{}m}, if {\it{}n} and {\it{}m} are not descendant of each other, and all the leaves dominated by {\it{}n} are to the right of the leaves dominated by {\it{}m}.}.
                      For every list {\it{}Desc} = [{\it{}di}\(\sb{1}\),{\it{}di}\(\sb{2}\),...,{\it{}di}\(\sb{sl}\)] \(\in\) {\it{}DESC} do: 
                          Let {\it{}Tree-Material} be the list of subtrees dominated 
                                   by the nodes in {\it{}Mapping}({\it{}lhs}\(\sb{j}\)), but, with the
                                   subtrees dominated by the nodes in {\it{}DESC}
                                   cut off from these trees 
                          Make {\it{}Matches} = \{ \{({\it{}lhs}\(\sb{j}\), {\it{}Tree-Material})\}\(\cup\){\it{}m}\(\cup\){\it{}m}\(\sb{j}\) \(\mid\)
                                  {\it{}m} \(\in\) {\it{}Matches} and {\it{}m}\(\sb{j}\) \(\in\) {\it{}Match}({\it{}children}\(\sb{lhs}\), {\it{}Desc})\} 
           Make {\it{}MATCHES} = {\it{}MATCHES} \(\cup\) {\it{}Matches}
       Return {\it{}MATCHES}
\end{alltt}

Finally we can define the process of structurally matching {\bf lhs} to
{\bf inp} as the evaluation of Match([root({\bf lhs})], [root({\bf inp})].
If the result is an empty set, the matching failed, otherwise the resulting
set is the set of possible matches that will be used for generating the
new trees (after being pruned by the feature equation matching).

\subsection{Output Generation}
\label{output-gen}

Although nothing has yet been said about the feature
equations, which is the subject of the next subsection, we assume that only
matches that meet the additional constraints imposed by feature equations
are considered for output. If no structural match survives feature equations
checking, that matching has failed.

If the process of matching {\bf lhs} to {\bf inp} fails, there are two 
alternative behaviors according to the value of a parameter\footnote{the
parameter is accessible at the Lisp interface by the name 
{\it XTAG::*metarules-copy-unmatched-trees*}.
At the end of section \ref{access} it is shown how to change the value
of this parameter through the XTAG interface.}. 
If the parameter is set to false, which is the {\it default} value, 
no output is generated. 
On the other hand, if 
it is set to true, then the own {\bf inp} tree is copied to the 
output\footnote{As it will be seen in section \ref{access} the cumulative
mode of application is not affected by this parameter.}.

If the process of matching succeeds, as many trees will be generated in the
output as the number of possible matches obtained in the process. For a 
given match, the output tree is generated by substituting in the {\bf rhs} tree
of the metarule the occurrences of variables by the material to which they have
been instantiated in the match. In the case of the typed-variable,
the name of the variable is just substituted by the name of the node to which
it has been instantiated from {\bf inp}. An important detail is how the
markers (foot, substitution, head, NA) are set at the output tree 
node. The rule is that, if the occurrence of the variable at the {\bf rhs}
tree has any marker, then the generated node will inherit ALL 
markers from the {\bf rhs} node. If it has no marker, then all the markers 
at the generated node will come from {\bf inp}. The exception to the rule is 
that if the generated node has any children, then it will not be marked
substitution, foot, or anchor, despite what the previous rule say.

The case of the non-typed variable, not surpringly, is not so simple. 
In the output tree, this node
will be substituted by the subtree list that was associated to this variable,
in the same order, attaching to the parent of this non-typed variable node.
But remember, that some subtrees may have been removed from some of the trees
in this list, maybe entire elements of this list, due to the effect of the
children of the metavariable in {\bf lhs}. 
It is a 
requirement that any occurence of a non-typed variable node at the {\bf rhs}
tree has exactly the same number of children than the unique occurence of
this non-typed variable node in {\bf lhs}. Hence, when generating the output
tree, the subtrees at {\bf rhs}
will be inserted exactly at the points where subtrees were removed during 
matching, in a positional, one to one correspondance. If one wants any
of these cutting points to be left empty, as if the subtree has been removed
at the substitution points, the corresponding children at the {\bf rhs} tree
has to be labelled {\bf EMPTY}.

For feature equations in the output trees see the next subsection. 
The generated comments deppend on a parameter setting as will be seen at the
end of section \ref{access}.

\subsection{Feature Matching}

In the previous subsections we have considered only the aspects of a metarule
involving the structural part of the XTAG trees. In a feature based grammar
as XTAG is, accounting for features is essential. A metarule is not really
worth if it doesn't account for the proper change of feature 
equations\footnote{Notice that what is really important is not the features
themselves, but the feature equations that relate the feature values of nodes
of the same tree} from the input to the output tree. 
The aspects that have to be considered here are:

\begin{itemize}
\item   Which feature equations should be required to be present in {\bf inp}
        in order for the match to succeed.

\item   Which feature equations should be generated in the output tree as a 
        function of the feature equations in the input tree.
\end{itemize}

Based on the combinations of these aspects the user may specify for a feature
equation to be considered in the following ways:

\begin{itemize}
\item   {\it Require \& Retain:} The feature equation
        is required to be in {\bf inp} in order for matching to succeed.
        Upon matching, the equation will be copied to the output tree.
        To achieve this behaviour, the equation must be placed in 
        the {\bf lhs} tree of the metarule preceded by a plus character
        (e.g. $+V.t:<trans>=+$)\footnote{Commutativity of equations is 
        accounted for in the system. Hence an equation $x=y$ can also be
        specified as $y=x$. Associativity is not accounted for and its need by
        an user is viewed as indicating misspecification at the input trees.}
        
\item   {\it Require \& Don't Copy:} The equation is required to be in 
        {\bf inp}
        for matching, but should not be copied to the output tree.
        To have this behaviout , the equation must be in {\bf lhs} preceded 
	by the minus character
        (e.g. $-NP_1:<case>=acc$).

\item	{\it Negative Requirement:} In order for matching to succeed the 
	equation should not be found in {\bf inp}. This is achieved by
	including the equation in {\bf lhs} preceded by a caret
	(e.g. $\verb|^|V.b:<passive>=-$).

\item   {\it Optional \& Don't Copy:} 
        The equation is not required for matching,
        but we have to make sure not to copy it to the output tree set of
        equations, regardless of it being present or not in {\bf inp}.
        Those equations must be in {\bf lhs} in raw form, i.e. neither preceded
        by a plus nor minus character
        (e.g. $S_r.b:<perfect>=VP.t:<perfect>$).

\item   {\it Optional \& Retain:} 
        The equation is not required for matching but,
        in case it is found in {\bf inp} it must be copied to the output tree.
        This is the {\it default} case, and hence these equations should not be
        present in the metarule specification.

\item   {\it Add:} The equation is not required for matching but we want it to
        be put in the output tree anyway.
        These equations are placed in raw form in the {\bf rhs} (notice in this
        case it is the right hand side tree).
\end{itemize}

There are also some directives available to handle feature equations. For 
convenience and conformance with the pre-existing interface functions,
this directives were defined to be included in the {\bf lhs} tree as feature 
equations among the equations for requirement/copy defined above. The
equations/directives will be interpreted and executed 
in the order they appear in the feature equations list definition 
of the {\bf lhs} tree. The general format of a directive is:

\centerline{D{\it{}name1} $:\ <$ {\it{}dummy1} $>\ =$ {\it{}name2}}

where ``D'' is a single character that specifies the directive, 
as listed below;
{\it name1} and {\it name2} are parameters of the directive; 
and {\it dummy1}, which may literally be the word ``dummy'' is required only
to conform to the pre-existing format for feature equations in XTAG.
There must be no blank space between the directive symbol and {\it name1}.
The currently implemented directives are:

\begin{itemize}
\item[$\backslash :$] replace {\it name1} with {\it name2} in all 
	equations from
	the input tree.
\item[{$|:$}] exchange {\it name1} with {\it name2} in all equations from
	the input tree.
\item[{$!:$}] remove all equations where {\it name1} appears 
	(here, {\it name2} is also dummy)
\end{itemize}

Notice that the equations are executed in order. Hence, for instance, if there
is a directive to remove equation E before an equation that requires E to
be present for matching, matching will allways fail. Similarly replacing and
exchanging feature names will affect and be affected by the behaviour of
surrounding equations. 

In the rest of this subsection we define the role of the meta-variables 
in the feature equations. Diversely of what we have done until here,
we will use the terms ``left'' and ``right hand
side'' ({\bf lhs} and {\bf rhs} for short) to refer to the sides of a
feature equation from a tree, {\bf NOT} to the sides of the metarule.

Non-typed variables don't play any role in the feature equations part.
Typed variables can be used in feature equations in both {\bf lhs} and 
{\bf rhs} side of the equation. 
They are intended to represent the nodes of the input tree with which
the variables have been instantiated. For each resulting match 
from the structural matching process the following is done:

\begin{itemize}
\item   The (typed) variables in the equations at {\bf lhs} and {\bf rhs} are 
        substituted by the names of the nodes they have been instantiated to.

\item   The requirements concerning feature equations are checked, according
        to the above rules.

\item   If the match survives feature equation checking, the proper output tree
        is generated, according to Section~\ref{output-gen} and to the 
        rules described above for the feature equations.
\end{itemize}

Finally, a new kind of metavariable, which is not used at the nodes, can be
introduced in the feature equations part. They have the same form of the
non-typed variables, i.e., a question mark followed by a number, and are used
in place of feature values and feature names. Hence, if the equation
$NP_r.b:<?2> = ?3$ appears in {\bf lhs}, this means, that all feature
equations of {\bf inp} that equate a certain  bottom attribute(?2) of node 
$NP_r$ to a certain feature value (?3) (but not to a feature path) will not 
be copied to the output. Notice that before the first time the variables ?2 
and ?3 match an equation from {\bf inp}, they are free and can match 
any feature
value/name. But after a match occurs, 
they become bound to the matched values, and
henceforth they'll only match values identical to that they have been
instantiated. That's why we said ``a certain'' value/name, as opposed to
``any''.

\setcounter{topnumber}{4}
\setcounter{bottomnumber}{4}
\setcounter{totalnumber}{4}
%\section{Examples of the Application of Metarules}

\section{Examples}
\label{examples}

Figure~\ref{wh-subj} shows a metarule for wh-movement of the subject. Among
the trees to which it have been applied are the basic trees of intransitive, 
transitive and ditransitive families (including prepositional complements),
passive trees of the same families, and ergative.

\begin{figure}[htb]
\begin{center}
\begin{tabular}{c@{\hspace{2em}}c}
\framebox{\psfig{figure=fig/lhs-wh-subj.ps,height=2.0in}} &
\framebox{\psfig{figure=fig/rhs-wh-subj.ps,height=2.5in}} \\
{lhs} & {rhs} \\
\end{tabular}
\end{center}
\caption{Metarule for wh-movement of subject}
\label{wh-subj}
\end{figure}

Figure~\ref{wh-obj} shows a metarule for wh-movement of an NP in object
position. Among
the trees to which it have been applied are the basic and passive trees of  
transitive and ditransitive families.

\begin{figure}[!htb]
\begin{center}
\begin{tabular}{c@{\hspace{2em}}c}
\framebox{\psfig{figure=fig/lhs-wh-obj.ps,height=2.9in}} &
\framebox{\psfig{figure=fig/rhs-wh-obj.ps,height=2.9in}} \\
{lhs} & {rhs} \\
\end{tabular}
\end{center}
\caption{Metarule for wh-movement of object}
\label{wh-obj}
\end{figure}

Figure~\ref{wh} shows a metarule for general wh-movement of an NP. 
It can be applied to
generate trees with either subject or object NP moved. We show in 
Figure~\ref{prep}, the basic tree for the family Tnx0Vnx1Pnx2 and the three
wh-trees generated by the application of the rule.

\begin{figure}[!htb]
\begin{center}
\begin{tabular}{c@{\hspace{2em}}c}
\framebox{\psfig{figure=fig/lhs-wh.ps,height=2.5in}} &
\framebox{\psfig{figure=fig/rhs-wh.ps,height=2.5in}} \\
{lhs} & {rhs} \\
\end{tabular}
\end{center}
\caption{Metarule for general wh movement of an NP}
\label{wh}
\end{figure}

\begin{figure}[!htb]
\begin{center}
\begin{tabular}{c@{\hspace{2em}}c}
\framebox{\psfig{figure=fig/prep.ps,height=3.0in}} &
\framebox{\psfig{figure=fig/prep1.ps,height=3.0in}} \\
{Tnx0Vnx1Pnx2} & {subject moved} \\
\\
\framebox{\psfig{figure=fig/prep2.ps,height=3.0in}} &
\framebox{\psfig{figure=fig/prep3.ps,height=3.0in}} \\
{NP object moved} & {NP object moved from PP} \\
\end{tabular}
\end{center}
\caption{Application of wh-movement rule to Tnx0Vnx1Pnx2}
\label{prep}
\end{figure}

\section{The Access to the Metarules through the XTAG Interface}
\label{access}

We first describe the access to the metarules subsystem using buffers with
single metarule applications. Then we proceed by describing the application of 
multiple metarules in what we call the parallel, sequential, and cumulative
modes to input tree files. 

We have defined conceptually a metarule as an ordered pair of trees. 
In the implementation
of the metarule subsystem it works the same: a metarule is a buffer with two
trees. The name of the metarule is the name of the buffer. The first tree that
appear in the main window under the metarule 
buffer is the {\it left hand side},
the next appearing below is the {\it right hand side}\footnote{Although a 
buffer is intended to implement the concept of a set (not a sequence) of trees
we take profit of the actual organization of the system to realize the
concept of (ordered) tree pair in the implementation.}. 
The positional approach allows us
to have naming freedom: the tree names
are irrelevant\footnote{so that even if we want to have mnemonic names 
resembling their distinct character - left or right hand side, - we have some
naming flexibility to call them e.g. {\it lhs23} or {\it lhs-passive}, ...}.
Since we can save buffers into text files, we can also talk about metarule
files. \\

The available options for applying a metarule which is in a buffer are:

\begin{itemize}
\item   For applying it to a single input tree, click in the name of the
        tree in the main window, and choose the option 
        {\it apply metarule to tree}. 
        You will be prompted for the name of the metarule
        to apply to the tree
        which should be, as we mentioned before, the name of the buffer that
        contains the metarule trees. The output trees will be generated
        at the end of the buffer that contains the input tree. The names of
        the trees depend of a LISP parameter {\it *metarules-change-name* }.
        If the value of the parameter is {\bf false} --- the {\it default} 
        value --- then the new trees will have the same name as the input, 
        otherwise, the name of the input tree followed by a dash (`-') and
        the name of the right hand side of the tree\footnote{the reason why 
        we do not use the name of the metarule, i.e. the name of the buffer,
        is because in some forms of application the metarules do not
        carry individual names, which as we'll see soon is the case when 
	a set of
        metarules from a file is applied.}.

        The value of the parameter can be changed by choosing {\it Tools} 
        at the menu bar and then either {\it name mr output trees =
        input}  or {\it append rhs name to mr output trees}.

        
\item   For applying it to all the trees of a buffer, click in the name of the 
        buffer that contains the trees and proceed as above. The output will
        be a new buffer with all the output trees. The name of the new buffer
        will be the same as the input buffer prefixed by "MR-". The names of
        the trees follow the conventions above.

\end{itemize}

The other options concern application to files (instead of buffers). 
Lets first define
the concepts of parallel, sequential and cumulative application of metarules. 
One metarule 
file can contain more than one metarule. The first two trees, i.e., the first
tree pair, form one metarule - lets call it $mr_0$. Subsequent pairs in the
sequence of trees define additional metarules --- 
$mr_1$, $mr_2$, ..., $mr_n$.

\begin{itemize}
\item We say that a metarule file is applied in parallel to a tree 
(see Figure~\ref{parallel})
if each of the 
metarules is applied independently to the input generating its particular 
output trees\footnote{remember a metarule application generates as many 
output trees as the number of matches}. We generalize the concept to the
application in parallel of a metarule file to a tree file (with possibly more 
than one tree), generating all the trees
as if each metarule in the metarule file was applied to each tree in the
input file.

\begin{figure}[htb]
\centerline{\psfig{figure=fig/parallel.ps,height=120pt}}
%\centerline{\psfig{figure=fig/parallel.ps,scale=60}}
%\centerline{\psfig{figure=fig/parallel.ps,width=330pt}}
\caption{Parallel application of metarules}
\label{parallel}
\end{figure}

\item We say that a metarule file $mr_0, mr_1, mr_2, ...,mr_n$ is applied in 
sequence to a input tree file 
(see Figure~\ref{sequential})
if we apply $mr_0$ to the trees of the input file, and
for each $0<i\leq n$ apply metarule $mr_i$ to the trees generated as a 
result of the application of $mr_{i-1}$.

\begin{figure}[htb]
\centerline{\psfig{figure=fig/sequential.ps,height=41pt}}
%\centerline{\psfig{figure=fig/sequential.ps,scale=60}}
\caption{Sequential application of metarules}
\label{sequential}
\end{figure}

\item Finally, the cumulative application is similar to the sequential, 
except that the input trees at each stage are by-passed to the output together
with the newly generated ones (see Figure~\ref{cumulative}).

\begin{figure}[htb]
\centerline{\psfig{figure=fig/cumulative.ps,height=53pt}}
%\centerline{\psfig{figure=fig/cumulative.ps,scale=60}}
\caption{Cumulative application of metarules}
\label{cumulative}
\end{figure}

\end{itemize}

Remember that in case of matching failure the output result is decided as 
explained in subsection ~\ref{output-gen} either to be empty or to be the 
input tree. The reflex here of having the parameter set for copying the input
is that for the parallel application the output will have as many copies of
the input as matching failures. For the sequential case the decision apply
at each level, and setting the parameter for copying, in a certain sense, 
guarantees for the 'pipe' not to break.
Due to its nature, and unlike the two other modes, the cumulative 
application is not affected by this parameter.

The options for application of metarules to files are available by clicking
at the menu item {\it Tools} and then choosing the appropriate function
among:

\begin{itemize}
\item   {\it Apply metarule to files:}  
        You'll be prompted for the metarule file name
        which should contain one metarule\footnote{if it contains more than 
        2 trees, the additional trees are ignored}, and for input file names.
        Each input file name {\bf inpfile} will be independently submitted to 
        the application of the metarule generating an output file with the 
        name    {\bf MR-inpfile}.

\item   {\it Apply metarules in parallel to files:}
        You'll be prompted for the metarules file name with one or more 
        metarules and for input file names.
        Each input file name {\bf inpfile} will be independently submitted to 
        the application of the metarules in parallel. For each parallel 
        application to a file {\bf inpfile} an output file with the 
        name    {\bf MRP-inpfile} will be generated.

\item   {\it Apply metarules in sequence to files:}  
        The interaction is as described for the application in parallel, 
        except that
        the application of the metarules are in sequence and that 
        the output files are prefixed by {\bf MRS-} instead of {\bf MRP-}.

\item   {\it Apply metarules cumulatively to files:}  
        The interaction is as described for the applications in parallel
        and in sequence, except that the mode of application is cumulative
        and that the output files are prefixed by {\bf MRC-}.
\end{itemize}

%For each case the user has the possibility of choosing what to do in the case
%of matching failure as discussed in the previous session.

The {\it Tools} menu also has entries to change the parameters of execution
of metarules. We saw earlier in this section how to set the parameter the 
controls the name of the tree. Another parameter, explained in 
Subsection~\ref{output-gen} is the one that 
controls the output result on matching failure. We can change it in the menu  
by selecting
either {\it copy input on mr matching failure} or 
{\it no output on mr matching failure}. Recall that this parameter don't
affect the cumulative mode.
The third parameter controls comments generation. By choosing,
{\it append metarule comments} at the {\it Tools} menu, the subsequent
metarule applications will produce output trees whose comments
are the comments at the {\bf lhs}
tree of the metarule followed by the coments at {\bf inp}, both parts 
introduced by appropriate headers, allowing the user to have a complete
history of each tree. By choosing
{\it do not append metarule comments} we make the comments at the output
trees be exactly the same at the input tree. The third option, 
{\it clear comments on metarule application}, causes the comment field 
to be left empty at the ouput trees.

The default values for the tree parameters when XTAG is started are set:
to generate the output trees with the same name as the input; to not to copy
the input tree in case of matching failure; and to add the metarule comments
to the output tree.

